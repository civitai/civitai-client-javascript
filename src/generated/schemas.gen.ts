// This file is auto-generated by @hey-api/openapi-ts

export const $AgeClassificationInput = {
  required: ['mediaUrl'],
  type: 'object',
  properties: {
    model: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
      description:
        'An optional model to use for age classification. If not provided, the default model will determined by the worker',
      nullable: true,
    },
    mediaUrl: {
      type: 'string',
      description:
        'The URL of the media to classify. This can either be a URL to an image or a video or a ZIP containing multiple images',
      format: 'uri',
    },
  },
  additionalProperties: false,
} as const;

export const $AgeClassificationOutput = {
  required: ['hasMinor', 'labels', 'prediction'],
  type: 'object',
  properties: {
    labels: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          $ref: '#/components/schemas/AgeClassifierLabel',
        },
      },
    },
    hasMinor: {
      type: 'boolean',
    },
    prediction: {
      $ref: '#/components/schemas/AgeClassificationPrediction',
    },
  },
  additionalProperties: false,
} as const;

export const $AgeClassificationPrediction = {
  enum: ['pass', 'fail'],
  type: 'string',
} as const;

export const $AgeClassificationStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/AgeClassificationInput',
        },
        output: {
          $ref: '#/components/schemas/AgeClassificationOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['ageClassification'],
      type: 'string',
    },
  },
  description: 'Age classification',
} as const;

export const $AgeClassificationStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/AgeClassificationInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['ageClassification'],
      type: 'string',
    },
  },
  description: 'Age classification',
} as const;

export const $AgeClassifierLabel = {
  required: ['age', 'boundingBox', 'isMinor'],
  type: 'object',
  properties: {
    age: {
      type: 'string',
    },
    isMinor: {
      type: 'boolean',
    },
    boundingBox: {
      type: 'array',
      items: {
        type: 'integer',
        format: 'int32',
      },
    },
  },
  additionalProperties: false,
} as const;

export const $BatchOCRSafetyClassificationInput = {
  required: ['mediaUrls'],
  type: 'object',
  properties: {
    mediaUrls: {
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
    },
  },
  additionalProperties: false,
} as const;

export const $BatchOCRSafetyClassificationOutput = {
  required: ['results'],
  type: 'object',
  properties: {
    results: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/BatchOCRSafetyClassificationResult',
      },
    },
  },
  additionalProperties: false,
} as const;

export const $BatchOCRSafetyClassificationResult = {
  required: ['classification', 'mediaUrl'],
  type: 'object',
  properties: {
    mediaUrl: {
      type: 'string',
      format: 'uri',
    },
    classification: {
      type: 'string',
    },
    text: {
      type: 'string',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $Blob = {
  required: ['available', 'id', 'type'],
  type: 'object',
  properties: {
    type: {
      type: 'string',
    },
    id: {
      type: 'string',
      description: 'Gets the id of the blob that contains this image.',
    },
    available: {
      type: 'boolean',
      description: 'Gets a value indicating whether the blob is available.',
    },
    url: {
      type: 'string',
      description: 'Gets a url that can be used to preview the blob.',
      format: 'uri',
      nullable: true,
    },
    urlExpiresAt: {
      type: 'string',
      description: 'Get when the url is set to expire',
      format: 'date-time',
      nullable: true,
    },
    jobId: {
      type: 'string',
      description: 'Get the id of the job that is associated with this blob.',
      nullable: true,
    },
    nsfwLevel: {
      $ref: '#/components/schemas/NSFWLevel',
    },
    blockedReason: {
      type: 'string',
      description:
        'Get an optional reason for why the blob was blocked. This is only set if the blob was blocked.',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Represents a blob that gets produced as part of a specific job',
  discriminator: {
    propertyName: 'type',
    mapping: {
      image: '#/components/schemas/ImageBlob',
      video: '#/components/schemas/VideoBlob',
    },
  },
} as const;

export const $BuzzClientAccount = {
  enum: ['user', 'generation'],
  type: 'string',
} as const;

export const $CivitaiWanVideoGenInput = {
  required: ['provider'],
  allOf: [
    {
      $ref: '#/components/schemas/WanVideoGenInput',
    },
    {
      type: 'object',
      properties: {
        width: {
          type: 'integer',
          format: 'int32',
        },
        height: {
          type: 'integer',
          format: 'int32',
        },
        model: {
          pattern:
            '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
          type: 'string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    provider: {
      enum: ['civitai'],
      type: 'string',
    },
  },
} as const;

export const $ComfyInput = {
  required: ['comfyWorkflow'],
  type: 'object',
  properties: {
    comfyWorkflow: {
      type: 'object',
      additionalProperties: {
        $ref: '#/components/schemas/ComfyNode',
      },
      description: 'Get the comfy workflow that needs to be executed',
    },
    quantity: {
      maximum: 100,
      minimum: 1,
      type: 'integer',
      description: 'The number of jobs to start with this workflow.',
      format: 'int32',
      default: 1,
    },
    imageMetadata: {
      type: 'string',
      description: 'External metadata that will be stored with the image',
      nullable: true,
    },
    useSpineComfy: {
      type: 'boolean',
      description: 'Opt-into using the spine controller exclusively',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $ComfyNode = {
  required: ['classType', 'inputs'],
  type: 'object',
  properties: {
    classType: {
      type: 'string',
    },
    meta: {
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
      nullable: true,
    },
    isChanged: {
      type: 'string',
      nullable: true,
    },
    inputs: {
      type: 'object',
      additionalProperties: {
        oneOf: [
          {
            type: 'string',
          },
          {
            type: 'number',
          },
          {
            type: 'boolean',
          },
          {
            maxItems: 2,
            minItems: 2,
            type: 'array',
            items: {
              type: 'number',
            },
          },
        ],
      },
    },
  },
  additionalProperties: false,
} as const;

export const $ComfyOutput = {
  type: 'object',
  properties: {
    blobs: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Blob',
      },
      description: 'Get a list of blobs that got generated by this comfy workflow step.',
    },
  },
  additionalProperties: false,
} as const;

export const $ComfyStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ComfyInput',
        },
        output: {
          $ref: '#/components/schemas/ComfyOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['comfy'],
      type: 'string',
    },
  },
  description: 'Comfy workflows',
} as const;

export const $ComfyStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ComfyInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['comfy'],
      type: 'string',
    },
  },
  description: 'Comfy workflows',
} as const;

export const $ContainerFormat = {
  enum: ['mp4', 'webM'],
  type: 'string',
} as const;

export const $CursedArrayOfTelemetryCursorAndWorkflow = {
  required: ['items', 'next'],
  type: 'object',
  properties: {
    next: {
      type: 'string',
    },
    items: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Workflow',
      },
    },
  },
  additionalProperties: false,
} as const;

export const $EchoInput = {
  required: ['message'],
  type: 'object',
  properties: {
    message: {
      type: 'string',
      description: 'The message to be returned in the output.',
    },
  },
  additionalProperties: false,
  description: 'Represents the input information needed for the Echo workflow step.',
} as const;

export const $EchoOutput = {
  required: ['message'],
  type: 'object',
  properties: {
    message: {
      type: 'string',
      description: 'The message to be returned.',
    },
  },
  additionalProperties: false,
  description: 'Represents the output information returned from the Echo workflow step.',
} as const;

export const $EchoStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/EchoInput',
        },
        output: {
          $ref: '#/components/schemas/EchoOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['echo'],
      type: 'string',
    },
  },
  description: 'Echo',
} as const;

export const $EchoStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/EchoInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['echo'],
      type: 'string',
    },
  },
  description: 'Echo',
} as const;

export const $EpochResult = {
  required: ['blobName', 'blobUrl'],
  type: 'object',
  properties: {
    epochNumber: {
      type: 'integer',
      format: 'int32',
    },
    blobName: {
      type: 'string',
      description: 'Get the name of the generated epoch assets',
    },
    blobSize: {
      type: 'integer',
      description: 'Get the total size in bytes of the asset',
      format: 'int64',
      nullable: true,
    },
    sampleImages: {
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
      description: 'Get a list of the names of the blobs that represent sample images',
    },
    blobUrl: {
      type: 'string',
      description: 'A presigned url that points to the epoch file',
      format: 'uri',
    },
  },
  additionalProperties: false,
  description: 'An epock result.',
} as const;

export const $FALWanVideoGenInput = {
  required: ['provider'],
  allOf: [
    {
      $ref: '#/components/schemas/WanVideoGenInput',
    },
    {
      type: 'object',
      properties: {
        aspectRatio: {
          enum: ['4:3', '16:9', '9:16'],
          type: 'string',
          default: '16:9',
        },
        enablePromptExpansion: {
          type: 'boolean',
          default: false,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    provider: {
      enum: ['fal'],
      type: 'string',
    },
  },
} as const;

export const $FileFormat = {
  enum: ['unknown', 'safeTensor', 'pickleTensor', 'diffusers', 'coreML', 'onnx'],
  type: 'string',
} as const;

export const $Flux1KontextDevImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/Flux1KontextImageGenInput',
    },
    {
      type: 'object',
      additionalProperties: false,
    },
  ],
  properties: {
    model: {
      enum: ['dev'],
      type: 'string',
    },
  },
} as const;

export const $Flux1KontextImageGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageGenInput',
    },
    {
      required: ['model', 'prompt'],
      type: 'object',
      properties: {
        model: {
          type: 'string',
        },
        prompt: {
          maxLength: 1000,
          minLength: 0,
          type: 'string',
        },
        images: {
          type: 'array',
          items: {
            type: 'string',
            description: 'Either A URL, A DataURL or a Base64 string',
          },
        },
        aspectRatio: {
          enum: ['21:9', '16:9', '4:3', '3:2', '1:1', '2:3', '3:4', '9:16', '9:21'],
          type: 'string',
        },
        outputFormat: {
          enum: ['jpeg', 'png'],
          type: 'string',
        },
        guidanceScale: {
          maximum: 20,
          minimum: 1,
          type: 'number',
          format: 'double',
        },
        quantity: {
          maximum: 4,
          minimum: 1,
          type: 'integer',
          format: 'int32',
        },
        seed: {
          type: 'integer',
          format: 'int64',
          nullable: true,
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'model',
        mapping: {
          pro: '#/components/schemas/Flux1KontextProImageGenInput',
          max: '#/components/schemas/Flux1KontextMaxImageGenInput',
          dev: '#/components/schemas/Flux1KontextDevImageGenInput',
        },
      },
    },
  ],
  properties: {
    engine: {
      enum: ['flux1-kontext'],
      type: 'string',
    },
  },
} as const;

export const $Flux1KontextMaxImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/Flux1KontextImageGenInput',
    },
    {
      type: 'object',
      additionalProperties: false,
    },
  ],
  properties: {
    model: {
      enum: ['max'],
      type: 'string',
    },
  },
} as const;

export const $Flux1KontextProImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/Flux1KontextImageGenInput',
    },
    {
      type: 'object',
      additionalProperties: false,
    },
  ],
  properties: {
    model: {
      enum: ['pro'],
      type: 'string',
    },
  },
} as const;

export const $FluxDevFastImageResourceTrainingInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageResourceTrainingInput',
    },
    {
      type: 'object',
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['flux-dev-fast'],
      type: 'string',
    },
  },
} as const;

export const $GoogleImageGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageGenInput',
    },
    {
      required: ['model', 'prompt'],
      type: 'object',
      properties: {
        model: {
          type: 'string',
        },
        prompt: {
          type: 'string',
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'model',
        mapping: {
          imagen4: '#/components/schemas/Imagen4ImageGenInput',
        },
      },
    },
  ],
  properties: {
    engine: {
      enum: ['google'],
      type: 'string',
    },
  },
} as const;

export const $HaiperVideoGenAspectRatio = {
  enum: ['16:9', '4:3', '1:1', '9:16', '3:4'],
  type: 'string',
} as const;

export const $HaiperVideoGenCameraMovement = {
  enum: ['none', 'panRight', 'panLeft', 'tiltUp', 'tiltDown', 'zoomIn', 'zoomOut'],
  type: 'string',
} as const;

export const $HaiperVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        negativePrompt: {
          type: 'string',
          nullable: true,
        },
        cameraMovement: {
          $ref: '#/components/schemas/HaiperVideoGenCameraMovement',
        },
        seed: {
          maximum: 4294967295,
          minimum: -1,
          type: 'integer',
          format: 'int64',
        },
        duration: {
          enum: [2, 4, 8],
          type: 'integer',
          format: 'int32',
        },
        aspectRatio: {
          $ref: '#/components/schemas/HaiperVideoGenAspectRatio',
        },
        model: {
          $ref: '#/components/schemas/HaiperVideoGenModel',
        },
        resolution: {
          enum: [720, 1080, 2160],
          type: 'integer',
          format: 'int32',
        },
        enablePromptEnhancer: {
          type: 'boolean',
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['haiper'],
      type: 'string',
    },
  },
} as const;

export const $HaiperVideoGenModel = {
  enum: ['v1_5', 'v2'],
  type: 'string',
} as const;

export const $HaiperVideoGenOutput = {
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenOutput',
    },
    {
      type: 'object',
      properties: {
        progress: {
          type: 'number',
          format: 'double',
          nullable: true,
        },
        externalTOSViolation: {
          type: 'boolean',
          nullable: true,
        },
        message: {
          type: 'string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
} as const;

export const $HumanoidImageMaskCategory = {
  enum: ['dresses', 'upperBody', 'lowerBody'],
  type: 'string',
} as const;

export const $HumanoidImageMaskInput = {
  required: ['category', 'imageUrl'],
  type: 'object',
  properties: {
    imageUrl: {
      type: 'string',
      format: 'uri',
    },
    category: {
      $ref: '#/components/schemas/HumanoidImageMaskCategory',
    },
  },
  additionalProperties: false,
} as const;

export const $HumanoidImageMaskOutput = {
  required: ['blob'],
  type: 'object',
  properties: {
    blob: {
      $ref: '#/components/schemas/Blob',
    },
  },
  additionalProperties: false,
} as const;

export const $HunyuanVdeoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        cfgScale: {
          maximum: 100,
          minimum: 0,
          type: 'number',
          format: 'double',
          default: 4,
        },
        frameRate: {
          type: 'integer',
          format: 'int32',
          default: 25,
        },
        duration: {
          maximum: 30,
          minimum: 1,
          type: 'integer',
          format: 'int32',
          default: 5,
        },
        seed: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        steps: {
          maximum: 50,
          minimum: 10,
          type: 'integer',
          format: 'int32',
          default: 20,
        },
        width: {
          type: 'integer',
          format: 'int32',
        },
        height: {
          type: 'integer',
          format: 'int32',
        },
        loras: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/VideoGenInputLora',
          },
        },
        model: {
          pattern:
            '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
          type: 'string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['hunyuan'],
      type: 'string',
    },
  },
} as const;

export const $ImageBlob = {
  required: ['type'],
  allOf: [
    {
      $ref: '#/components/schemas/Blob',
    },
    {
      type: 'object',
      properties: {
        width: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        height: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    type: {
      enum: ['image'],
      type: 'string',
    },
  },
} as const;

export const $ImageGenInput = {
  required: ['engine'],
  type: 'object',
  properties: {
    engine: {
      type: 'string',
    },
  },
  additionalProperties: false,
  discriminator: {
    propertyName: 'engine',
    mapping: {
      openai: '#/components/schemas/OpenApiImageGenInput',
      'flux1-kontext': '#/components/schemas/Flux1KontextImageGenInput',
      google: '#/components/schemas/GoogleImageGenInput',
    },
  },
} as const;

export const $ImageGenOutput = {
  required: ['images'],
  type: 'object',
  properties: {
    images: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ImageBlob',
      },
      description: 'A collection of output images.',
    },
  },
  additionalProperties: false,
} as const;

export const $ImageGenStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ImageGenInput',
        },
        output: {
          $ref: '#/components/schemas/ImageGenOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageGen'],
      type: 'string',
    },
  },
  description: 'Image Generation',
} as const;

export const $ImageGenStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ImageGenInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageGen'],
      type: 'string',
    },
  },
  description: 'Image Generation',
} as const;

export const $ImageJobControlNet = {
  type: 'object',
  properties: {
    preprocessor: {
      $ref: '#/components/schemas/ImageTransformer',
    },
    weight: {
      type: 'number',
      description: 'A value representing the weight applied to the ControlNet.',
      format: 'double',
    },
    startStep: {
      type: 'number',
      description: 'A value representing the start step selected for the ControlNet.',
      format: 'double',
    },
    endStep: {
      type: 'number',
      description: 'A value representing the end step selected for the ControlNet.',
      format: 'double',
    },
  },
  additionalProperties: false,
  description: 'Information for a controlnet provided for a text to image input.',
} as const;

export const $ImageJobNetworkParams = {
  type: 'object',
  properties: {
    strength: {
      type: 'number',
      description: 'In case of Lora and LoCon, set the strength of the network',
      format: 'double',
      nullable: true,
    },
    triggerWord: {
      type: 'string',
      description: 'In case of a TextualInversion, set the trigger word of the network',
      nullable: true,
    },
    type: {
      type: 'string',
      description: 'A legacy type set by the consumer',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $ImageResouceTrainingModerationStatus = {
  enum: ['evaluating', 'underReview', 'approved', 'rejected'],
  type: 'string',
} as const;

export const $ImageResourceTrainingInput = {
  required: ['engine', 'model', 'trainingData', 'trainingDataImagesCount'],
  type: 'object',
  properties: {
    engine: {
      type: 'string',
    },
    model: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
      description: 'The primary model to train upon.',
    },
    trainingData: {
      type: 'string',
      description: 'A url referring data to use in training.',
      format: 'uri',
    },
    trainingDataImagesCount: {
      type: 'integer',
      description:
        'The number of images embedded in this training data. This is used to calculate the cost of training.',
      format: 'int32',
    },
    loraName: {
      type: 'string',
      description: 'The desired lora name.',
      default: 'my-lora',
    },
    samplePrompts: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'A selection of sample prompts.',
    },
  },
  additionalProperties: false,
  description: 'Input for an image resource training step.',
  discriminator: {
    propertyName: 'engine',
    mapping: {
      kohya: '#/components/schemas/KohyaImageResourceTrainingInput',
      'flux-dev-fast': '#/components/schemas/FluxDevFastImageResourceTrainingInput',
      musubi: '#/components/schemas/MusubiImageResourceTrainingInput',
    },
  },
} as const;

export const $ImageResourceTrainingOutput = {
  required: ['epochs', 'moderationStatus', 'sampleImagesPrompts'],
  type: 'object',
  properties: {
    moderationStatus: {
      $ref: '#/components/schemas/ImageResouceTrainingModerationStatus',
    },
    epochs: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/EpochResult',
      },
      description: 'An array of epochs.',
    },
    sampleImagesPrompts: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'The selected prompts for sample images',
    },
    sampleInputImages: {
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
      description: 'The selected images for sample images',
      nullable: true,
    },
    storedAsAssets: {
      type: 'boolean',
      description: `Get wether the blobs are actually stored as assets
Assets are deprecated and require a different retrieval mechanism`,
      nullable: true,
    },
    eta: {
      type: 'number',
      description: 'Get an estimate in minutes on how long the work is expected to take',
      format: 'double',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $ImageResourceTrainingStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ImageResourceTrainingInput',
        },
        output: {
          $ref: '#/components/schemas/ImageResourceTrainingOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageResourceTraining'],
      type: 'string',
    },
  },
  description: 'LORA Training',
} as const;

export const $ImageResourceTrainingStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/ImageResourceTrainingInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageResourceTraining'],
      type: 'string',
    },
  },
  description: 'LORA Training',
} as const;

export const $ImageTransformer = {
  enum: ['canny', 'depthZoe', 'softedgePidinet', 'rembg'],
  type: 'string',
  description: 'Available image transformers.',
} as const;

export const $ImageUploadOutput = {
  required: ['blob'],
  type: 'object',
  properties: {
    blob: {
      $ref: '#/components/schemas/Blob',
    },
  },
  additionalProperties: false,
} as const;

export const $ImageUploadStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: "The workflow's input.",
        },
        output: {
          $ref: '#/components/schemas/ImageUploadOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageUpload'],
      type: 'string',
    },
  },
  description: 'Image upload',
} as const;

export const $ImageUploadStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: 'Input for the ImageUploadStep step.',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['imageUpload'],
      type: 'string',
    },
  },
  description: 'Image upload',
} as const;

export const $Imagen4ImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/GoogleImageGenInput',
    },
    {
      required: ['prompt'],
      type: 'object',
      properties: {
        prompt: {
          maxLength: 1000,
          minLength: 0,
          type: 'string',
        },
        negativePrompt: {
          maxLength: 1000,
          minLength: 0,
          type: 'string',
        },
        aspectRatio: {
          enum: ['1:1', '16:9', '9:16', '3:4', '4:3'],
          type: 'string',
        },
        numImages: {
          maximum: 4,
          minimum: 1,
          type: 'integer',
          format: 'int32',
        },
        seed: {
          type: 'integer',
          format: 'int64',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    model: {
      enum: ['imagen4'],
      type: 'string',
    },
  },
} as const;

export const $JobSupport = {
  enum: ['unsupported', 'unavailable', 'available'],
  type: 'string',
  description: 'Available levels of job support.',
} as const;

export const $JsonPatchDocument = {
  type: 'array',
  items: {
    $ref: '#/components/schemas/JsonPatchOperation',
  },
  description: 'Array of operations to perform',
} as const;

export const $JsonPatchOperation = {
  required: ['op', 'path'],
  type: 'object',
  properties: {
    op: {
      enum: ['add', 'remove', 'replace', 'move', 'copy', 'test'],
      type: 'string',
      description:
        "The operation type. Allowed values: 'add', 'remove', 'replace', 'move', 'copy', 'test'.",
    },
    path: {
      type: 'string',
      description:
        'The JSON Pointer path to the property in the target document where the operation is to be applied.',
    },
    from: {
      type: 'string',
      description: 'Should be a path, required when using move, copy',
    },
    value: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'number',
        },
        {
          type: 'boolean',
        },
        {
          type: 'object',
        },
        {
          type: 'array',
        },
      ],
      description:
        "The value to apply for 'add', 'replace', or 'test' operations. Not required for 'remove', 'move', or 'copy'.",
      nullable: true,
    },
  },
  description:
    'Describes a single operation in a JSON Patch document. Includes the operation type, the target property path, and the value to be used.',
} as const;

export const $KlingCameraControl = {
  type: 'object',
  properties: {
    config: {
      $ref: '#/components/schemas/KlingCameraControlConfig',
    },
  },
  additionalProperties: false,
} as const;

export const $KlingCameraControlConfig = {
  type: 'object',
  properties: {
    horizontal: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description:
        "Horizontal, controls the camera's movement along the horizontal axis (translation along the x-axis).",
      format: 'double',
      nullable: true,
    },
    vertical: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description:
        "Vertical, controls the camera's movement along the vertical axis (translation along the y-axis).",
      format: 'double',
      nullable: true,
    },
    pan: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description:
        "Pan, controls the camera's rotation in the horizontal plane (rotation around the y-axis).",
      format: 'double',
      nullable: true,
    },
    tilt: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description:
        "Tilt, controls the camera's rotation in the horizontal plane (rotation around the y-axis).",
      format: 'double',
      nullable: true,
    },
    roll: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description: "Roll, controls the camera's rolling amount (rotation around the z-axis).",
      format: 'double',
      nullable: true,
    },
    zoom: {
      maximum: 10,
      minimum: -10,
      type: 'number',
      description:
        "Zoom, controls the change in the camera's focal length, affecting the proximity of the field of view.",
      format: 'double',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $KlingMode = {
  enum: ['standard', 'professional'],
  type: 'string',
} as const;

export const $KlingModel = {
  enum: ['v1', 'v1_5', 'v1_6', 'v2'],
  type: 'string',
} as const;

export const $KlingVideoGenAspectRatio = {
  enum: ['16:9', '9:16', '1:1'],
  type: 'string',
} as const;

export const $KlingVideoGenDuration = {
  enum: ['5', '10'],
  type: 'string',
} as const;

export const $KlingVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        model: {
          $ref: '#/components/schemas/KlingModel',
        },
        negativePrompt: {
          type: 'string',
          nullable: true,
        },
        cfgScale: {
          maximum: 1,
          minimum: 0,
          type: 'number',
          format: 'double',
          default: 0.5,
        },
        mode: {
          $ref: '#/components/schemas/KlingMode',
        },
        aspectRatio: {
          $ref: '#/components/schemas/KlingVideoGenAspectRatio',
        },
        duration: {
          $ref: '#/components/schemas/KlingVideoGenDuration',
        },
        cameraControl: {
          $ref: '#/components/schemas/KlingCameraControl',
        },
        sourceImageUrl: {
          type: 'string',
          format: 'uri',
          nullable: true,
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['kling'],
      type: 'string',
    },
  },
} as const;

export const $KohyaImageResourceTrainingInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageResourceTrainingInput',
    },
    {
      type: 'object',
      properties: {
        maxTrainEpochs: {
          maximum: 20,
          minimum: 0,
          type: 'integer',
          description:
            'An epoch is one set of learning. By default, we will save a maximum of 20 epochs (evenly distributed), and they are all available for download.',
          format: 'int32',
          default: 5,
        },
        numRepeats: {
          maximum: 5000,
          minimum: 1,
          type: 'integer',
          description:
            'Num Repeats defines how many times each individual image gets put into VRAM. As opposed to batch size, which is how many images are placed into VRAM at once.',
          format: 'int32',
          default: 8,
        },
        trainBatchSize: {
          maximum: 9,
          minimum: 1,
          type: 'integer',
          description:
            'Batch size is the number of images that will be placed into VRAM at once. A batch size of 2 will train two images at a time, simultaneously.',
          format: 'int32',
          nullable: true,
        },
        resolution: {
          maximum: 1024,
          minimum: 512,
          type: 'integer',
          description:
            'Specify the maximum resolution of training images. If the training images exceed the resolution specified here, they will be scaled down to this resolution',
          format: 'int32',
          nullable: true,
        },
        enableBucket: {
          type: 'boolean',
          description:
            'Sorts images into buckets by size for the purposes of training. If your training images are all the same size, you can turn this option off, but leaving it on has no effect.',
          default: true,
        },
        shuffleCaption: {
          type: 'boolean',
          description:
            'Randomly changes the order of your tags during training. The intent of shuffling is to improve learning. If you are using captions (sentences), this option has no meaning.',
          default: false,
        },
        keepTokens: {
          maximum: 3,
          minimum: 0,
          type: 'integer',
          description: `If your training images have tags, you can randomly shuffle them.
However, if you have words that you want to keep at the beginning, you can use this option to specify "Keep the first 0 words at the beginning".
This option does nothing if the Shuffle Tags option is off.`,
          format: 'int32',
          default: 0,
        },
        clipSkip: {
          maximum: 4,
          minimum: 1,
          type: 'integer',
          description: `Determines which layer's vector output will be used. There are 12 layers, and setting the skip will select "xth from the end" of the total layers. For anime, we use 2. For everything else, 1.`,
          format: 'int32',
        },
        flipAugmentation: {
          type: 'boolean',
          description:
            'If this option is turned on, the image will be horizontally flipped randomly. It can learn left and right angles, which is useful when you want to learn symmetrical people and objects.',
          default: false,
        },
        unetLR: {
          maximum: 1,
          minimum: 0,
          type: 'number',
          description:
            'Sets the learning rate for U-Net. This is the learning rate when performing additional learning on each attention block (and other blocks depending on the setting) in U-Net',
          format: 'double',
          default: 0.00005,
        },
        textEncoderLR: {
          maximum: 1,
          minimum: 0,
          type: 'number',
          description:
            'Sets the learning rate for the text encoder. The effect of additional training on text encoders affects the entire U-Net.',
          format: 'double',
          default: 0.00005,
        },
        lrScheduler: {
          enum: ['constant', 'cosine', 'cosine_with_restarts', 'linear'],
          type: 'string',
          description:
            'You can change the learning rate in the middle of learning. A scheduler is a setting for how to change the learning rate.',
          nullable: true,
        },
        lrSchedulerNumCycles: {
          maximum: 4,
          minimum: 1,
          type: 'integer',
          description:
            'This option specifies how many cycles the scheduler runs during training. It is only used when "cosine_with_restarts" or "polynomial" is used as the scheduler.',
          format: 'int32',
          default: 3,
        },
        minSnrGamma: {
          maximum: 20,
          minimum: 0,
          type: 'integer',
          description: `Learning is performed by putting noise of various strengths on the training image,
but depending on the difference in strength of the noise on which it is placed, learning will be
stable by moving closer to or farther from the learning target.
            
Min SNR gamma was introduced to compensate for that. When learning images have little noise,
it may deviate greatly from the target, so try to suppress this jump.`,
          format: 'int32',
          nullable: true,
        },
        networkDim: {
          maximum: 256,
          minimum: 1,
          type: 'integer',
          description:
            'The larger the Dim setting, the more learning information can be stored, but the possibility of learning unnecessary information other than the learning target increases. A larger Dim also increases LoRA file size.',
          format: 'int32',
          nullable: true,
        },
        networkAlpha: {
          maximum: 256,
          minimum: 1,
          type: 'integer',
          description: `The smaller the Network alpha value, the larger the stored LoRA neural net weights.
For example, with an Alpha of 16 and a Dim of 32, the strength of the weight used is 16/32 = 0.5,
meaning that the learning rate is only half as powerful as the Learning Rate setting.
            
If Alpha and Dim are the same number, the strength used will be 1 and will have no effect on the learning rate.`,
          format: 'int32',
          nullable: true,
        },
        noiseOffset: {
          maximum: 1,
          minimum: 0,
          type: 'number',
          description:
            'Adds noise to training images. 0 adds no noise at all. A value of 1 adds strong noise.',
          format: 'double',
          nullable: true,
        },
        optimizerType: {
          type: 'string',
          description: `The optimizer determines how to update the neural net weights during training.
Various methods have been proposed for smart learning, but the most commonly used in LoRA learning
is "AdamW8bit" or "Adafactor" for SDXL.`,
          nullable: true,
        },
        targetSteps: {
          type: 'integer',
          format: 'int32',
          nullable: true,
          readOnly: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['kohya'],
      type: 'string',
    },
  },
} as const;

export const $LightricksAspectRatio = {
  enum: ['1:1', '16:9', '9:16', '3:2', '2:3'],
  type: 'string',
} as const;

export const $LightricksVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        negativePrompt: {
          type: 'string',
          nullable: true,
        },
        cfgScale: {
          maximum: 100,
          minimum: 0,
          type: 'number',
          format: 'double',
          default: 4,
        },
        frameRate: {
          type: 'integer',
          format: 'int32',
          default: 25,
        },
        duration: {
          maximum: 30,
          minimum: 1,
          type: 'integer',
          format: 'int32',
          default: 5,
        },
        seed: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        steps: {
          maximum: 50,
          minimum: 10,
          type: 'integer',
          format: 'int32',
          default: 20,
        },
        aspectRatio: {
          $ref: '#/components/schemas/LightricksAspectRatio',
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
        expandPrompt: {
          type: 'boolean',
          default: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['lightricks'],
      type: 'string',
    },
  },
} as const;

export const $MiniMaxVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        model: {
          $ref: '#/components/schemas/MiniMaxVideoGenModel',
        },
        enablePromptEnhancer: {
          type: 'boolean',
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['minimax'],
      type: 'string',
    },
  },
} as const;

export const $MiniMaxVideoGenModel = {
  enum: ['hailou'],
  type: 'string',
} as const;

export const $MochiVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        seed: {
          maximum: 2147483647,
          minimum: -1,
          type: 'integer',
          format: 'int64',
        },
        enablePromptEnhancer: {
          type: 'boolean',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['mochi'],
      type: 'string',
    },
  },
} as const;

export const $MusubiImageResourceTrainingInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageResourceTrainingInput',
    },
    {
      type: 'object',
      properties: {
        maxTrainEpochs: {
          maximum: 20,
          minimum: 0,
          type: 'integer',
          description:
            'An epoch is one set of learning. By default, we will save a maximum of 20 epochs (evenly distributed), and they are all available for download.',
          format: 'int32',
          default: 5,
        },
        numRepeats: {
          maximum: 5000,
          minimum: 1,
          type: 'integer',
          description:
            'Num Repeats defines how many times each individual image gets put into VRAM. As opposed to batch size, which is how many images are placed into VRAM at once.',
          format: 'int32',
          default: 8,
        },
        trainBatchSize: {
          maximum: 9,
          minimum: 1,
          type: 'integer',
          description:
            'Batch size is the number of images that will be placed into VRAM at once. A batch size of 2 will train two images at a time, simultaneously.',
          format: 'int32',
          nullable: true,
        },
        resolution: {
          maximum: 1024,
          minimum: 512,
          type: 'integer',
          description:
            'Specify the maximum resolution of training images. If the training images exceed the resolution specified here, they will be scaled down to this resolution',
          format: 'int32',
          nullable: true,
        },
        enableBucket: {
          type: 'boolean',
          description:
            'Sorts images into buckets by size for the purposes of training. If your training images are all the same size, you can turn this option off, but leaving it on has no effect.',
          default: true,
        },
        unetLR: {
          maximum: 1,
          minimum: 0,
          type: 'number',
          description:
            'Sets the learning rate for U-Net. This is the learning rate when performing additional learning on each attention block (and other blocks depending on the setting) in U-Net',
          format: 'double',
          default: 0.00005,
        },
        lrScheduler: {
          enum: ['constant', 'cosine', 'cosine_with_restarts', 'linear'],
          type: 'string',
          description:
            'You can change the learning rate in the middle of learning. A scheduler is a setting for how to change the learning rate.',
          nullable: true,
        },
        lrSchedulerNumCycles: {
          maximum: 4,
          minimum: 1,
          type: 'integer',
          description:
            'This option specifies how many cycles the scheduler runs during training. It is only used when "cosine_with_restarts" or "polynomial" is used as the scheduler.',
          format: 'int32',
          default: 3,
        },
        networkDim: {
          maximum: 256,
          minimum: 1,
          type: 'integer',
          description:
            'The larger the Dim setting, the more learning information can be stored, but the possibility of learning unnecessary information other than the learning target increases. A larger Dim also increases LoRA file size.',
          format: 'int32',
          nullable: true,
        },
        networkAlpha: {
          maximum: 256,
          minimum: 1,
          type: 'integer',
          description: `The smaller the Network alpha value, the larger the stored LoRA neural net weights.
For example, with an Alpha of 16 and a Dim of 32, the strength of the weight used is 16/32 = 0.5,
meaning that the learning rate is only half as powerful as the Learning Rate setting.
            
If Alpha and Dim are the same number, the strength used will be 1 and will have no effect on the learning rate.`,
          format: 'int32',
          nullable: true,
        },
        optimizerType: {
          type: 'string',
          description: `The optimizer determines how to update the neural net weights during training.
Various methods have been proposed for smart learning, but the most commonly used in LoRA learning
is "AdamW8bit" or "Adafactor" for SDXL.`,
          nullable: true,
        },
        targetSteps: {
          type: 'integer',
          format: 'int32',
          nullable: true,
          readOnly: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['musubi'],
      type: 'string',
    },
  },
} as const;

export const $NSFWLevel = {
  enum: ['pg', 'pG13', 'r', 'x', 'xxx', 'na'],
  type: 'string',
} as const;

export const $OpenAIDallE2CreateImageGenInput = {
  required: ['operation'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenAIDallE2ImageGenInput',
    },
    {
      type: 'object',
      properties: {
        background: {
          enum: ['auto', 'transparent', 'opaque'],
          type: 'string',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    operation: {
      enum: ['createImage'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIDallE2EditImageInput = {
  required: ['operation'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenAIDallE2ImageGenInput',
    },
    {
      required: ['image'],
      type: 'object',
      properties: {
        image: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
        },
        mask: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    operation: {
      enum: ['editImage'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIDallE2ImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenApiImageGenInput',
    },
    {
      required: ['operation', 'prompt', 'size'],
      type: 'object',
      properties: {
        operation: {
          type: 'string',
        },
        prompt: {
          maxLength: 1000,
          minLength: 0,
          type: 'string',
        },
        size: {
          enum: ['256x256', '512x512', '1024x1024'],
          type: 'string',
        },
        quantity: {
          maximum: 10,
          minimum: 1,
          type: 'integer',
          format: 'int32',
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'operation',
        mapping: {
          createImage: '#/components/schemas/OpenAIDallE2CreateImageGenInput',
          editImage: '#/components/schemas/OpenAIDallE2EditImageInput',
        },
      },
    },
  ],
  properties: {
    model: {
      enum: ['dall-e-2'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIDallE3CreateImageGenInput = {
  required: ['operation'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenAIDallE3ImageGenInput',
    },
    {
      type: 'object',
      properties: {
        background: {
          enum: ['auto', 'transparent', 'opaque'],
          type: 'string',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    operation: {
      enum: ['createImage'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIDallE3ImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenApiImageGenInput',
    },
    {
      required: ['operation', 'prompt', 'size'],
      type: 'object',
      properties: {
        operation: {
          type: 'string',
        },
        prompt: {
          maxLength: 4000,
          minLength: 0,
          type: 'string',
        },
        size: {
          enum: ['1024x1024', '1792x1024', '1024x1792'],
          type: 'string',
        },
        style: {
          enum: ['natural', 'vivid'],
          type: 'string',
        },
        quality: {
          enum: ['auto', 'hd', 'standard'],
          type: 'string',
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'operation',
        mapping: {
          createImage: '#/components/schemas/OpenAIDallE3CreateImageGenInput',
        },
      },
    },
  ],
  properties: {
    model: {
      enum: ['dall-e-3'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIGpt1CreateImageInput = {
  required: ['operation'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenAIGpt1ImageGenInput',
    },
    {
      type: 'object',
      additionalProperties: false,
    },
  ],
  properties: {
    operation: {
      enum: ['createImage'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIGpt1EditImageInput = {
  required: ['operation'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenAIGpt1ImageGenInput',
    },
    {
      required: ['images'],
      type: 'object',
      properties: {
        images: {
          type: 'array',
          items: {
            type: 'string',
            description: 'Either A URL, A DataURL or a Base64 string',
          },
        },
        mask: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    operation: {
      enum: ['editImage'],
      type: 'string',
    },
  },
} as const;

export const $OpenAIGpt1ImageGenInput = {
  required: ['model'],
  allOf: [
    {
      $ref: '#/components/schemas/OpenApiImageGenInput',
    },
    {
      required: ['operation', 'prompt'],
      type: 'object',
      properties: {
        operation: {
          type: 'string',
        },
        prompt: {
          maxLength: 32000,
          minLength: 0,
          type: 'string',
        },
        size: {
          enum: ['1024x1024', '1536x1024', '1024x1536'],
          type: 'string',
        },
        quantity: {
          maximum: 10,
          minimum: 1,
          type: 'integer',
          format: 'int32',
        },
        background: {
          enum: ['auto', 'transparent', 'opaque'],
          type: 'string',
        },
        quality: {
          enum: ['auto', 'high', 'medium', 'low'],
          type: 'string',
          nullable: true,
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'operation',
        mapping: {
          createImage: '#/components/schemas/OpenAIGpt1CreateImageInput',
          editImage: '#/components/schemas/OpenAIGpt1EditImageInput',
        },
      },
    },
  ],
  properties: {
    model: {
      enum: ['gpt-image-1'],
      type: 'string',
    },
  },
} as const;

export const $OpenApiImageGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/ImageGenInput',
    },
    {
      required: ['model', 'prompt'],
      type: 'object',
      properties: {
        model: {
          type: 'string',
        },
        prompt: {
          type: 'string',
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'model',
        mapping: {
          'gpt-image-1': '#/components/schemas/OpenAIGpt1ImageGenInput',
          'dall-e-2': '#/components/schemas/OpenAIDallE2ImageGenInput',
          'dall-e-3': '#/components/schemas/OpenAIDallE3ImageGenInput',
        },
      },
    },
  ],
  properties: {
    engine: {
      enum: ['openai'],
      type: 'string',
    },
  },
} as const;

export const $Priority = {
  enum: ['high', 'normal', 'low'],
  type: 'string',
  description: 'Available options for priority.',
} as const;

export const $ProblemDetails = {
  type: 'object',
  properties: {
    type: {
      type: 'string',
      nullable: true,
    },
    title: {
      type: 'string',
      nullable: true,
    },
    status: {
      type: 'integer',
      format: 'int32',
      nullable: true,
    },
    detail: {
      type: 'string',
      nullable: true,
    },
    instance: {
      type: 'string',
      nullable: true,
    },
  },
  additionalProperties: {},
} as const;

export const $ResourceInfo = {
  required: ['air', 'downloadUrls', 'hashes', 'size'],
  type: 'object',
  properties: {
    air: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
      description: 'An AIR ID for the resource.',
    },
    size: {
      type: 'integer',
      description: 'The resource size in bytes.',
      format: 'int64',
    },
    hashes: {
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
      description: 'A collection of hashes.',
    },
    downloadUrls: {
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
      description: 'An array of download urls.',
    },
    resourceName: {
      type: 'string',
      description: 'The name of the resource.',
      nullable: true,
    },
    versionName: {
      type: 'string',
      description: 'The name of the version.',
      nullable: true,
    },
    invalidateAt: {
      type: 'string',
      description: 'The date time to invalidate at.',
      format: 'date-time',
      nullable: true,
    },
    earlyAccessEndsAt: {
      type: 'string',
      description: 'A DateTime representing when early access for the resource ends.',
      format: 'date-time',
      nullable: true,
    },
    checkPermission: {
      type: 'boolean',
      description: 'A bool indicating if permission is required to use this resource.',
    },
    canGenerate: {
      type: 'boolean',
      description: 'A bool indicating if generation is enabled for this resource.',
    },
    freeTrialLimit: {
      type: 'integer',
      description:
        'An optional limit on the number of uses for this resource per user that has early acccess.',
      format: 'int32',
      nullable: true,
    },
    requiresAuthorization: {
      type: 'boolean',
      description: 'Wether this resource requires authorization.',
      nullable: true,
    },
    fileFormat: {
      $ref: '#/components/schemas/FileFormat',
    },
    hasMatureContentRestriction: {
      type: 'boolean',
      description: `A boolean indicating whether this resource restricts mature content generation.
If resources with this restriction are used in generation, then generations will automatically be enforced to not generate mature content`,
    },
    popularityRank: {
      type: 'number',
      description: 'Get a rank between 0-1 on the popularity of the resource.',
      format: 'double',
      nullable: true,
    },
    isFeatured: {
      type: 'boolean',
      description: 'Get wether this resource is featured',
      nullable: true,
    },
    publishedAt: {
      type: 'string',
      description: 'The date at which this model got published',
      format: 'date-time',
      nullable: true,
    },
    hasNSFWContentRestriction: {
      type: 'boolean',
      description: `A boolean indicating whether this resource restricts to SFW content generation.
NSFWContent covers X and AA whereas MatureContent includes R rated content.`,
    },
  },
  additionalProperties: false,
  description: 'Details for a specific resource.',
} as const;

export const $Scheduler = {
  enum: [
    'eulerA',
    'euler',
    'lms',
    'heun',
    'dpM2',
    'dpM2A',
    'dpM2SA',
    'dpM2M',
    'dpmsde',
    'dpmFast',
    'dpmAdaptive',
    'lmsKarras',
    'dpM2Karras',
    'dpM2AKarras',
    'dpM2SAKarras',
    'dpM2MKarras',
    'dpmsdeKarras',
    'ddim',
    'plms',
    'uniPC',
    'undefined',
    'lcm',
    'ddpm',
    'deis',
    'dpM3MSDE',
  ],
  type: 'string',
  description: 'The available options for schedulers used in image generation.',
} as const;

export const $TextToImageInput = {
  required: ['height', 'prompt', 'width'],
  type: 'object',
  properties: {
    quantity: {
      maximum: 100,
      minimum: 1,
      type: 'integer',
      description: 'The number of batches to run.',
      format: 'int32',
      default: 1,
    },
    batchSize: {
      maximum: 100,
      minimum: 1,
      type: 'integer',
      description: 'The size of each batch',
      format: 'int32',
      default: 1,
    },
    model: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
      description: 'The AIR of the checkpoint model to use for generation.',
      default: 'urn:air:sd1:checkpoint:civitai:4384@128713',
    },
    additionalNetworks: {
      type: 'object',
      additionalProperties: {
        $ref: '#/components/schemas/ImageJobNetworkParams',
      },
      description:
        'Get or set a associative list of additional networks. Use the AIR of the network as the key.',
    },
    controlNets: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ImageJobControlNet',
      },
      description: 'Get or set a associative list of ControlNets.',
    },
    prompt: {
      type: 'string',
      description: 'The provided text prompt.',
    },
    negativePrompt: {
      type: 'string',
      description: 'The provided negative text prompt.',
      nullable: true,
    },
    scheduler: {
      $ref: '#/components/schemas/Scheduler',
    },
    steps: {
      maximum: 150,
      minimum: 1,
      type: 'integer',
      description: 'The number of steps for image generation.',
      format: 'int32',
      default: 30,
    },
    cfgScale: {
      maximum: 30,
      minimum: 1,
      type: 'number',
      description: 'The CFG scale value for image generation.',
      format: 'double',
      default: 7.5,
    },
    width: {
      maximum: 4084,
      minimum: 64,
      type: 'integer',
      description: 'The desired image width in pixels.',
      format: 'int32',
      default: 512,
    },
    height: {
      maximum: 4084,
      minimum: 64,
      type: 'integer',
      description: 'The desired image height in pixels.',
      format: 'int32',
      default: 512,
    },
    seed: {
      maximum: 4294967295,
      minimum: 0,
      type: 'integer',
      description:
        'The seed to use in image generation. Defaults to a random value if left unpopulated.',
      format: 'int64',
    },
    clipSkip: {
      type: 'integer',
      description: 'The clip skip value for image generation.',
      format: 'int32',
      default: 2,
    },
    imageMetadata: {
      type: 'string',
      description: 'External metadata that will be stored with the image',
      nullable: true,
    },
    engine: {
      type: 'string',
      description: 'An optional engine to use for generation.',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Input for an text to image step.',
} as const;

export const $TextToImageOutput = {
  required: ['images'],
  type: 'object',
  properties: {
    images: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ImageBlob',
      },
      description: 'A collection of output images.',
    },
  },
  additionalProperties: false,
  description: 'Represents the output of a TextToImage workflow step.',
} as const;

export const $TextToImageStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/TextToImageInput',
        },
        output: {
          $ref: '#/components/schemas/TextToImageOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['textToImage'],
      type: 'string',
    },
  },
  description: 'TextToImage',
} as const;

export const $TextToImageStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/TextToImageInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['textToImage'],
      type: 'string',
    },
  },
  description: 'TextToImage',
} as const;

export const $TransactionInfo = {
  required: ['amount', 'type'],
  type: 'object',
  properties: {
    type: {
      $ref: '#/components/schemas/TransactionType',
    },
    amount: {
      maximum: 2147483647,
      minimum: 0,
      type: 'integer',
      description: 'The transaction amount.',
      format: 'int32',
    },
    id: {
      type: 'string',
      description: 'The transaction ID.',
      nullable: true,
    },
    accountType: {
      $ref: '#/components/schemas/BuzzClientAccount',
    },
  },
  additionalProperties: false,
  description: 'Transaction information.',
} as const;

export const $TransactionSummary = {
  type: 'object',
  properties: {
    list: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/TransactionInfo',
      },
      description: 'Get a list of individual transactions.',
    },
  },
  additionalProperties: false,
} as const;

export const $TransactionType = {
  enum: ['debit', 'credit'],
  type: 'string',
} as const;

export const $TranscodeInput = {
  required: ['sourceUrl'],
  type: 'object',
  properties: {
    sourceUrl: {
      type: 'string',
      format: 'uri',
    },
    containerFormat: {
      $ref: '#/components/schemas/ContainerFormat',
    },
    width: {
      type: 'integer',
      format: 'int32',
    },
    destinationUrl: {
      type: 'string',
      format: 'uri',
      nullable: true,
    },
  },
  additionalProperties: false,
} as const;

export const $TranscodeOutput = {
  required: ['available', 'id', 'jobId'],
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description: 'Gets the id of the blob that contains the media.',
    },
    available: {
      type: 'boolean',
      description: 'Gets a value indicating whether the media is available.',
    },
    url: {
      type: 'string',
      description: 'Gets a url that can be used to preview the media.',
      format: 'uri',
      nullable: true,
    },
    urlExpiresAt: {
      type: 'string',
      description: 'Get when the url is set to expire',
      format: 'date-time',
      nullable: true,
    },
    jobId: {
      type: 'string',
      description: 'Get the id of the job that is associated with this media.',
    },
  },
  additionalProperties: false,
} as const;

export const $TranscodeStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/TranscodeInput',
        },
        output: {
          $ref: '#/components/schemas/TranscodeOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['transcode'],
      type: 'string',
    },
  },
  description: 'Transcoding',
  'x-preview': true,
  'x-internal': true,
} as const;

export const $TryOnUInput = {
  required: ['garmentUrl', 'subjectUrl'],
  type: 'object',
  properties: {
    subjectUrl: {
      type: 'string',
      format: 'uri',
    },
    garmentUrl: {
      type: 'string',
      format: 'uri',
    },
    subjectMaskUrl: {
      type: 'string',
      format: 'uri',
    },
    subjectMaskBlobKey: {
      type: 'string',
    },
    garmentDescription: {
      type: 'string',
    },
    maskSubject: {
      type: 'boolean',
    },
    cropSubject: {
      type: 'boolean',
    },
    steps: {
      type: 'integer',
      format: 'int32',
    },
    seed: {
      type: 'integer',
      format: 'int32',
    },
  },
  additionalProperties: false,
} as const;

export const $TryOnUOutput = {
  required: ['blob'],
  type: 'object',
  properties: {
    blob: {
      $ref: '#/components/schemas/Blob',
    },
  },
  additionalProperties: false,
} as const;

export const $UpdateWorkflowRequest = {
  type: 'object',
  properties: {
    status: {
      $ref: '#/components/schemas/UpdateWorkflowStatus',
    },
    metadata: {
      type: 'object',
      additionalProperties: {},
      description: 'An optional set of new properties to set on the workflow.',
      nullable: true,
    },
    tags: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'An optional set of new tags to set on the workflow.',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'An request for updating a workflow.',
} as const;

export const $UpdateWorkflowStatus = {
  enum: ['canceled'],
  type: 'string',
  description: 'Available statuses for updating workflows.',
} as const;

export const $UpdateWorkflowStepRequest = {
  required: ['metadata'],
  type: 'object',
  properties: {
    metadata: {
      type: 'object',
      additionalProperties: {},
      description: 'An set of new properties to set on the workflow step.',
    },
  },
  additionalProperties: false,
} as const;

export const $ValidationProblemDetails = {
  type: 'object',
  properties: {
    type: {
      type: 'string',
      nullable: true,
    },
    title: {
      type: 'string',
      nullable: true,
    },
    status: {
      type: 'integer',
      format: 'int32',
      nullable: true,
    },
    detail: {
      type: 'string',
      nullable: true,
    },
    instance: {
      type: 'string',
      nullable: true,
    },
    errors: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    },
  },
  additionalProperties: {},
} as const;

export const $ValueTupleOfStringAndInt32 = {
  type: 'object',
  additionalProperties: false,
} as const;

export const $Veo3AspectRatio = {
  enum: ['16:9', '9:16', '1:1'],
  type: 'string',
} as const;

export const $Veo3VideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        negativePrompt: {
          type: 'string',
          nullable: true,
        },
        enablePromptEnhancer: {
          type: 'boolean',
        },
        aspectRatio: {
          $ref: '#/components/schemas/Veo3AspectRatio',
        },
        duration: {
          type: 'integer',
          format: 'int32',
          default: 8,
        },
        generateAudio: {
          type: 'boolean',
        },
        seed: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        fastMode: {
          type: 'boolean',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['veo3'],
      type: 'string',
    },
  },
} as const;

export const $VideoBlob = {
  required: ['type'],
  allOf: [
    {
      $ref: '#/components/schemas/Blob',
    },
    {
      type: 'object',
      properties: {
        width: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        height: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    type: {
      enum: ['video'],
      type: 'string',
    },
  },
} as const;

export const $VideoEnhancementInput = {
  required: ['sourceUrl'],
  type: 'object',
  properties: {
    sourceUrl: {
      type: 'string',
      format: 'uri',
    },
    upscaler: {
      $ref: '#/components/schemas/VideoEnhancementInputUpscalerOptions',
    },
    interpolation: {
      $ref: '#/components/schemas/VideoEnhancementInputInterpolationOptions',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoEnhancementInputInterpolationOptions = {
  required: ['multiplier'],
  type: 'object',
  properties: {
    multiplier: {
      type: 'integer',
      format: 'int32',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoEnhancementInputUpscalerOptions = {
  required: ['height', 'width'],
  type: 'object',
  properties: {
    model: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
      nullable: true,
    },
    width: {
      type: 'integer',
      format: 'int32',
    },
    height: {
      type: 'integer',
      format: 'int32',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoEnhancementOutput = {
  required: ['video'],
  type: 'object',
  properties: {
    video: {
      $ref: '#/components/schemas/VideoBlob',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoEnhancementStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/VideoEnhancementInput',
        },
        output: {
          $ref: '#/components/schemas/VideoEnhancementOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['videoEnhancement'],
      type: 'string',
    },
  },
  description: 'Upscale videos and/or interpolate frames',
} as const;

export const $VideoEnhancementStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/VideoEnhancementInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['videoEnhancement'],
      type: 'string',
    },
  },
  description: 'Upscale videos and/or interpolate frames',
} as const;

export const $VideoGenInput = {
  required: ['engine', 'prompt'],
  type: 'object',
  properties: {
    engine: {
      type: 'string',
    },
    prompt: {
      type: 'string',
    },
  },
  additionalProperties: false,
  discriminator: {
    propertyName: 'engine',
    mapping: {
      haiper: '#/components/schemas/HaiperVideoGenInput',
      mochi: '#/components/schemas/MochiVideoGenInput',
      kling: '#/components/schemas/KlingVideoGenInput',
      minimax: '#/components/schemas/MiniMaxVideoGenInput',
      lightricks: '#/components/schemas/LightricksVideoGenInput',
      hunyuan: '#/components/schemas/HunyuanVdeoGenInput',
      wan: '#/components/schemas/WanVideoGenInput',
      vidu: '#/components/schemas/ViduVideoGenInput',
      veo3: '#/components/schemas/Veo3VideoGenInput',
    },
  },
} as const;

export const $VideoGenInputLora = {
  required: ['air', 'strength'],
  type: 'object',
  properties: {
    air: {
      pattern:
        '^(?:urn:)?(?:air:)?(?:(?<ecosystem>[a-zA-Z0-9_\\-\\/]+):)?(?:(?<type>[a-zA-Z0-9_\\-\\/]+):)?(?<source>[a-zA-Z0-9_\\-\\/]+):(?<id>[a-zA-Z0-9_\\-\\/\\.]+)(?:@(?<version>[a-zA-Z0-9_\\-\\/.=,]+))?(?:\\.(?<format>[a-zA-Z0-9_\\-]+))?$',
      type: 'string',
    },
    strength: {
      type: 'number',
      format: 'double',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoGenOutput = {
  type: 'object',
  properties: {
    video: {
      $ref: '#/components/schemas/VideoBlob',
    },
  },
  additionalProperties: false,
} as const;

export const $VideoGenStep = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStep',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/VideoGenInput',
        },
        output: {
          $ref: '#/components/schemas/VideoGenOutput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['videoGen'],
      type: 'string',
    },
  },
  description: 'Video generation',
} as const;

export const $VideoGenStepTemplate = {
  required: ['$type'],
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowStepTemplate',
    },
    {
      required: ['input'],
      type: 'object',
      properties: {
        input: {
          $ref: '#/components/schemas/VideoGenInput',
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    $type: {
      enum: ['videoGen'],
      type: 'string',
    },
  },
  description: 'Video generation',
} as const;

export const $ViduVideoGenInput = {
  required: ['engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      type: 'object',
      properties: {
        enablePromptEnhancer: {
          type: 'boolean',
          default: true,
        },
        seed: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
        style: {
          $ref: '#/components/schemas/ViduVideoGenStyle',
        },
        duration: {
          enum: [4, 8],
          type: 'integer',
          format: 'int32',
          default: 4,
        },
        endSourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
        model: {
          $ref: '#/components/schemas/ViduVideoGenModel',
        },
        aspectRatio: {
          enum: ['16:9', '9:16', '1:1'],
          type: 'string',
          nullable: true,
        },
        movementAmplitude: {
          enum: ['auto', 'small', 'medium', 'large'],
          type: 'string',
          nullable: true,
        },
        images: {
          type: 'array',
          items: {
            type: 'string',
            description: 'Either A URL, A DataURL or a Base64 string',
          },
        },
        enableBackgroundMusic: {
          type: 'boolean',
          default: false,
        },
      },
      additionalProperties: false,
    },
  ],
  properties: {
    engine: {
      enum: ['vidu'],
      type: 'string',
    },
  },
} as const;

export const $ViduVideoGenModel = {
  enum: ['default', 'q1'],
  type: 'string',
} as const;

export const $ViduVideoGenStyle = {
  enum: ['general', 'anime'],
  type: 'string',
} as const;

export const $WanVideoGenInput = {
  required: ['provider', 'engine'],
  allOf: [
    {
      $ref: '#/components/schemas/VideoGenInput',
    },
    {
      required: ['provider'],
      type: 'object',
      properties: {
        provider: {
          type: 'string',
        },
        sourceImage: {
          type: 'string',
          description: 'Either A URL, A DataURL or a Base64 string',
          nullable: true,
        },
        cfgScale: {
          maximum: 100,
          minimum: 0,
          type: 'number',
          format: 'double',
          default: 4,
        },
        frameRate: {
          type: 'integer',
          format: 'int32',
          default: 24,
        },
        duration: {
          maximum: 30,
          minimum: 1,
          type: 'integer',
          format: 'int32',
          default: 5,
        },
        seed: {
          type: 'integer',
          format: 'int32',
          nullable: true,
        },
        steps: {
          maximum: 50,
          minimum: 10,
          type: 'integer',
          format: 'int32',
          default: 20,
        },
        loras: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/VideoGenInputLora',
          },
        },
      },
      additionalProperties: false,
      discriminator: {
        propertyName: 'provider',
        mapping: {
          wan: '#/components/schemas/WanVideoGenInput',
          civitai: '#/components/schemas/CivitaiWanVideoGenInput',
          fal: '#/components/schemas/FALWanVideoGenInput',
        },
      },
    },
  ],
  properties: {
    provider: {
      enum: ['wan'],
      type: 'string',
    },
    engine: {
      enum: ['wan'],
      type: 'string',
    },
  },
} as const;

export const $Workflow = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description: 'The ID for the workflow.',
      nullable: true,
    },
    createdAt: {
      type: 'string',
      description: 'The date / time the workflow was created.',
      format: 'date-time',
    },
    transactions: {
      $ref: '#/components/schemas/TransactionSummary',
    },
    metadata: {
      type: 'object',
      additionalProperties: {},
      description: 'A collection of user defined metadata for the workflow.',
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    startedAt: {
      type: 'string',
      description: 'The date / time the workflow was started. Null if not yet started.',
      format: 'date-time',
      nullable: true,
    },
    completedAt: {
      type: 'string',
      description: 'The date / time the workflow was completed. Null if not yet complete.',
      format: 'date-time',
      nullable: true,
    },
    tags: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'An optional list of tags for the workflow.',
    },
    arguments: {
      type: 'object',
      additionalProperties: {},
      description: 'Get an associated collection of arguments',
    },
    steps: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowStep',
      },
      description: 'The steps for the workflow.',
    },
    callbacks: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowCallback',
      },
      description: 'An array of callback details for the workflow.',
    },
    tips: {
      $ref: '#/components/schemas/WorkflowTips',
    },
    cost: {
      $ref: '#/components/schemas/WorkflowCost',
    },
    nsfwLevel: {
      $ref: '#/components/schemas/NSFWLevel',
    },
    experimental: {
      type: 'boolean',
      description: 'Get or set whether this workflow is experimental',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow.',
} as const;

export const $WorkflowCallback = {
  required: ['type', 'url'],
  type: 'object',
  properties: {
    url: {
      type: 'string',
      description: 'The url for the callback.',
      format: 'uri',
    },
    type: {
      type: 'array',
      items: {
        enum: [
          'workflow:*',
          'workflow:unassigned',
          'workflow:processing',
          'workflow:succeeded',
          'workflow:failed',
          'workflow:expired',
          'workflow:canceled',
          'step:*',
          'step:unassigned',
          'step:processing',
          'step:succeeded',
          'step:failed',
          'step:expired',
          'step:canceled',
          'job:*',
          'job:unassigned',
          'job:processing',
          'job:succeeded',
          'job:failed',
          'job:expired',
          'job:canceled',
        ],
        type: 'string',
        example: 'workflow:succeeded',
      },
      description: 'An array of event types to send to the callback.',
    },
  },
  additionalProperties: false,
  description: 'Details of a callback setup for a workflow.',
} as const;

export const $WorkflowCost = {
  type: 'object',
  properties: {
    base: {
      type: 'integer',
      description: 'The base cost of this request, excludsing any tips',
      format: 'int32',
    },
    factors: {
      type: 'object',
      additionalProperties: {
        type: 'number',
        format: 'double',
      },
      description: 'A breakdown of the cost factors for this request',
      nullable: true,
    },
    fixed: {
      type: 'object',
      additionalProperties: {
        type: 'integer',
        format: 'int32',
      },
      description: 'A fixed set of cost additions for this request',
      nullable: true,
    },
    tips: {
      $ref: '#/components/schemas/WorkflowCostTips',
    },
    total: {
      type: 'integer',
      description: 'The total cost of this request, including tips',
      format: 'int32',
    },
  },
  additionalProperties: false,
} as const;

export const $WorkflowCostTips = {
  required: ['civitai', 'creators'],
  type: 'object',
  properties: {
    civitai: {
      type: 'integer',
      description: 'The buzz tipped to Civitai',
      format: 'int32',
    },
    creators: {
      type: 'integer',
      description: "The buzz tipped to the Creators who's resources were used",
      format: 'int32',
    },
  },
  additionalProperties: false,
  description: 'Get the cost of tips',
} as const;

export const $WorkflowEvent = {
  required: ['status', 'workflowId'],
  type: 'object',
  properties: {
    workflowId: {
      type: 'string',
      description: 'The ID that represents the corresponding workflow.',
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    timestamp: {
      type: 'string',
      description: 'A timestamp for when this event got raised',
      format: 'date-time',
    },
    $type: {
      type: 'string',
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow event.',
} as const;

export const $WorkflowStatus = {
  enum: [
    'unassigned',
    'preparing',
    'scheduled',
    'processing',
    'succeeded',
    'failed',
    'expired',
    'canceled',
  ],
  type: 'string',
  description: 'Values available to represent workflow status.',
} as const;

export const $WorkflowStep = {
  required: ['$type', 'name'],
  type: 'object',
  properties: {
    $type: {
      type: 'string',
    },
    name: {
      type: 'string',
      description: 'The name of the workflow step. Used to allow steps to refer to one another.',
    },
    priority: {
      $ref: '#/components/schemas/Priority',
    },
    timeout: {
      type: 'string',
      description: 'The maximum time to wait for this step to complete.',
      format: 'date-span',
      nullable: true,
    },
    retries: {
      type: 'integer',
      description: 'The maximum number of times this step should be retried.',
      format: 'int32',
      nullable: true,
    },
    jobs: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowStepJob',
      },
      description: 'The jobs generated by this step.',
      nullable: true,
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    startedAt: {
      type: 'string',
      description: 'The date / time the step was started. Null if not yet started.',
      format: 'date-time',
      nullable: true,
    },
    completedAt: {
      type: 'string',
      description: 'The date / time the step was completed. Null if not yet completed.',
      format: 'date-time',
      nullable: true,
    },
    metadata: {
      type: 'object',
      additionalProperties: {},
      description: 'A collection of user defined metadata for the workflow step.',
    },
    estimatedProgressRate: {
      type: 'number',
      description:
        'An estimation on the current progression of this step, or null if there is no estimation',
      format: 'double',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow step.',
  discriminator: {
    propertyName: '$type',
    mapping: {
      ageClassification: '#/components/schemas/AgeClassificationStep',
      comfy: '#/components/schemas/ComfyStep',
      echo: '#/components/schemas/EchoStep',
      imageGen: '#/components/schemas/ImageGenStep',
      imageResourceTraining: '#/components/schemas/ImageResourceTrainingStep',
      imageUpload: '#/components/schemas/ImageUploadStep',
      textToImage: '#/components/schemas/TextToImageStep',
      transcode: '#/components/schemas/TranscodeStep',
      videoEnhancement: '#/components/schemas/VideoEnhancementStep',
      videoGen: '#/components/schemas/VideoGenStep',
    },
  },
} as const;

export const $WorkflowStepEvent = {
  required: ['status', 'stepName', 'workflowId'],
  type: 'object',
  properties: {
    workflowId: {
      type: 'string',
      description: 'The workflow ID.',
    },
    stepName: {
      type: 'string',
      description: "The workflow step's name.",
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    $type: {
      type: 'string',
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow step event.',
} as const;

export const $WorkflowStepJob = {
  required: ['id'],
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description: "The job's ID.",
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    startedAt: {
      type: 'string',
      description: 'The date / time the job started. Null if not yet started.',
      format: 'date-time',
      nullable: true,
    },
    completedAt: {
      type: 'string',
      description: 'The date / time the job completed. Null if not yet completed.',
      format: 'date-time',
      nullable: true,
    },
    queuePosition: {
      $ref: '#/components/schemas/WorkflowStepJobQueuePosition',
    },
    cost: {
      type: 'number',
      description: "The job's cost.",
      format: 'double',
    },
    estimatedProgressRate: {
      type: 'number',
      description:
        'An estimation on the current progression of this job, or null if there is no estimation',
      format: 'double',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a job produced by a workflow step.',
} as const;

export const $WorkflowStepJobEvent = {
  required: ['jobId', 'status', 'stepName', 'workflowId'],
  type: 'object',
  properties: {
    workflowId: {
      type: 'string',
      description: 'The workflow ID.',
    },
    stepName: {
      type: 'string',
      description: "The step's name.",
    },
    jobId: {
      type: 'string',
      description: "The job's ID.",
    },
    status: {
      $ref: '#/components/schemas/WorkflowStatus',
    },
    $type: {
      type: 'string',
    },
    progress: {
      type: 'number',
      format: 'double',
      nullable: true,
    },
    reason: {
      type: 'string',
      nullable: true,
    },
    blockedReason: {
      type: 'string',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow step job event.',
} as const;

export const $WorkflowStepJobQueuePosition = {
  required: ['support'],
  type: 'object',
  properties: {
    support: {
      $ref: '#/components/schemas/JobSupport',
    },
    precedingJobs: {
      type: 'integer',
      description: 'The number of preceding jobs in the queue.',
      format: 'int32',
      nullable: true,
    },
    startAt: {
      type: 'string',
      description: 'An estimated date / time for when the job will start.',
      format: 'date-time',
      nullable: true,
    },
    completeAt: {
      type: 'string',
      description: 'An estimated date / time for when the job will complete.',
      format: 'date-time',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: "Details of the workflow step job's queue position.",
} as const;

export const $WorkflowStepTemplate = {
  required: ['$type'],
  type: 'object',
  properties: {
    $type: {
      type: 'string',
    },
    name: {
      type: 'string',
      description: 'The name of the workflow step. Used to allow steps to refer to one another.',
      nullable: true,
    },
    priority: {
      $ref: '#/components/schemas/Priority',
    },
    timeout: {
      type: 'string',
      description: 'The maximum time to wait for this step to complete.',
      format: 'date-span',
      nullable: true,
    },
    retries: {
      type: 'integer',
      description: 'The maximum number of times this step should be retried.',
      format: 'int32',
      nullable: true,
    },
    metadata: {
      type: 'object',
      additionalProperties: {},
      description: 'A collection of user defined metadata for the workflow step.',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a workflow step template.',
  discriminator: {
    propertyName: '$type',
    mapping: {
      ageClassification: '#/components/schemas/AgeClassificationStepTemplate',
      comfy: '#/components/schemas/ComfyStepTemplate',
      echo: '#/components/schemas/EchoStepTemplate',
      imageGen: '#/components/schemas/ImageGenStepTemplate',
      imageResourceTraining: '#/components/schemas/ImageResourceTrainingStepTemplate',
      imageUpload: '#/components/schemas/ImageUploadStepTemplate',
      textToImage: '#/components/schemas/TextToImageStepTemplate',
      videoEnhancement: '#/components/schemas/VideoEnhancementStepTemplate',
      videoGen: '#/components/schemas/VideoGenStepTemplate',
    },
  },
} as const;

export const $WorkflowTemplate = {
  required: ['steps'],
  type: 'object',
  properties: {
    metadata: {
      type: 'object',
      additionalProperties: {},
      description:
        'A collection of user defined metadata that can be used to store additional information about the workflow.',
      nullable: true,
    },
    tags: {
      maxItems: 10,
      uniqueItems: true,
      type: 'array',
      items: {
        type: 'string',
      },
      description: `A list of tags associated with this workflow.
Tags are indexed and can be used to search for workflows.
At most 10 tags can be assigned to a workflow. Each tag can be at most 200 characters long.`,
      nullable: true,
    },
    steps: {
      minItems: 1,
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowStepTemplate',
      },
      description: 'An array of steps that compose this workflow.',
    },
    callbacks: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowCallback',
      },
      description: 'An array of callbacks to be triggered during the lifetime of the workflow.',
      nullable: true,
    },
    tips: {
      $ref: '#/components/schemas/WorkflowTips',
    },
    arguments: {
      type: 'object',
      additionalProperties: {},
      description: 'Get an associated collection of arguments',
      nullable: true,
    },
    nsfwLevel: {
      $ref: '#/components/schemas/NSFWLevel',
    },
    experimental: {
      type: 'boolean',
      description: 'Get or set whether this workflow is experimental',
      nullable: true,
    },
  },
  additionalProperties: false,
  description: 'Details of a requested workflow.',
} as const;

export const $WorkflowTips = {
  required: ['civitai', 'creators'],
  type: 'object',
  properties: {
    civitai: {
      type: 'number',
      description: 'The rate of tipping that should be allocated to civitai',
      format: 'double',
    },
    creators: {
      type: 'number',
      description:
        'The rate of tipping that should be allocated to creators involved in this workflow',
      format: 'double',
    },
  },
  additionalProperties: false,
} as const;
