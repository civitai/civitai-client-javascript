// This file is auto-generated by @hey-api/openapi-ts

export type ConfigurationOptions = {
  /**
   * Get or set the priority of this configuration if multiple configurations apply to the same worker
   */
  priority?: number;
  selector: Expression;
  /**
   * Get or set the specification associated with this configuration
   */
  spec: unknown;
};

export type ConfigurationStatus = {
  configurationId: string;
  assigned?: number;
  targeted?: number;
  applied?: number;
};

export type ContainerFormat = 'mp4' | 'webM';

export type CreateConfigurationResult = {
  configurationId: string;
};

export type CreateWorkerResult = {
  workerId: string;
};

export type CursedArrayOfTelemetryCursorAndWorkflow = {
  next: string;
  items: Array<Workflow>;
};

export type DynamicAssignment = {
  fromPath: string;
  toPath: string;
  defaultValue?: unknown;
};

/**
 * Represents the input information needed for the Echo workflow step.
 */
export type EchoInput = {
  /**
   * The message to be returned in the output.
   */
  message: string;
};

/**
 * Represents the output information returned from the Echo workflow step.
 */
export type EchoOutput = {
  /**
   * The message to be returned.
   */
  message: string;
};

/**
 * This step is intended for testing purposes.
 */
export type EchoStep = WorkflowStep & {
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob>;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
  input: EchoInput;
  output?: EchoOutput;
  $type: 'echo';
};

export type EchoStepTemplate = WorkflowStepTemplate & {
  $type: 'echo';
  input: EchoInput;
};

export type EcosystemElement = {
  [key: string]: EcosystemElement;
};

/**
 * An epock result.
 */
export type EpochResult = {
  /**
   * Get the name of the generated epoch assets
   */
  blobName: string;
  /**
   * Get the total size in bytes of the asset
   */
  blobSize: number;
  /**
   * Get a list of the names of the blobs that represent sample images
   */
  sampleImages?: Array<string>;
};

export type Expression = {
  [key: string]: unknown;
};

/**
 * Represents an image that is the result of a TextToImage workflow step.
 */
export type Image = {
  /**
   * Gets the id of the blob that contains this image.
   */
  id: string;
  /**
   * Gets a value indicating whether the image is available.
   */
  available: boolean;
  /**
   * Gets a url that can be used to preview the image.
   */
  url?: string | null;
  /**
   * Get when the url is set to expire
   */
  urlExpiresAt?: string | null;
  /**
   * Get the id of the job that is associated with this image.
   */
  jobId: string;
};

/**
 * Information for a controlnet provided for a text to image input.
 */
export type ImageJobControlNet = {
  preprocessor?: ImageTransformer;
  /**
   * A value representing the weight applied to the ControlNet.
   */
  weight?: number;
  /**
   * A value representing the start step selected for the ControlNet.
   */
  startStep?: number;
  /**
   * A value representing the end step selected for the ControlNet.
   */
  endStep?: number;
};

export type ImageJobNetworkParams = {
  /**
   * In case of Lora and LoCon, set the strength of the network
   */
  strength?: number | null;
  /**
   * In case of a TextualInversion, set the trigger word of the network
   */
  triggerWord?: string | null;
  /**
   * A legacy type set by the consumer
   */
  type?: string | null;
};

/**
 * Parameters for a text to image step.
 */
export type ImageJobParams = {
  /**
   * The prompt for the text to image generation.
   */
  prompt?: string | null;
  /**
   * The negative prompt for the text to image generation.
   */
  negativePrompt?: string | null;
  scheduler?: Scheduler;
  /**
   * The number of steps for the text to image generation.
   */
  steps?: number;
  /**
   * The CFG scale value for the text to image generation.
   */
  cfgScale?: number | null;
  /**
   * The width for the image to be generated in pixels.
   */
  width: number;
  /**
   * The height for the image to be generated in pixels.
   */
  height: number;
  /**
   * The seed for the text to image generation.
   */
  seed?: number;
  /**
   * The clip skip value for the text to image generation.
   */
  clipSkip?: number;
};

/**
 * Input for an image resource training step.
 */
export type ImageResourceTrainingInput = {
  /**
   * The primary model to train upon.
   */
  model: string;
  /**
   * A url referring data to use in training.
   */
  trainingData: string;
  /**
   * The desired learning rate for the U-Net.
   */
  unetLR?: number;
  /**
   * The desired learning rate for the text encoder.
   */
  textEncoderLR?: number;
  /**
   * The desired optimizer type.
   */
  optimizerType?: string;
  /**
   * The desired network dimensionality.
   */
  networkDim?: number;
  /**
   * The desired network alpha.
   */
  networkAlpha?: number;
  /**
   * The desired learning rate scheduler.
   */
  lrScheduler?: string;
  /**
   * The desired maximum number of training epochs.
   */
  maxTrainEpochs?: number;
  /**
   * The desired number of repeats.
   */
  numRepeats?: number;
  /**
   * The desired resolution.
   */
  resolution?: number;
  /**
   * The lora type.
   */
  loraType?: string;
  /**
   * EnableBucket?
   */
  enableBucket?: boolean;
  /**
   * KeepTokens?
   */
  keepTokens?: number;
  /**
   * The desired number of cycles for the learning rate scheduler.
   */
  lrSchedulerNumCycles?: number;
  /**
   * The desired training batch size.
   */
  trainBatchSize?: number;
  /**
   * MinSnrGamm?
   */
  minSnrGamma?: number;
  /**
   * Provided arguments for the optimizer.
   */
  optimizerArgs?: string;
  /**
   * ShuffleCaption?
   */
  shuffleCaption?: boolean;
  /**
   * The desired lora name.
   */
  loraName?: string;
  /**
   * The desired noise offset.
   */
  noiseOffset?: number;
  /**
   * A selection of sample prompts.
   */
  samplePrompts?: Array<string>;
};

export type ImageResourceTrainingJob = Job & {
  /**
   * An AIR representing the model to use.
   */
  model: string;
  /**
   * A url referring data that needs to be trained upon
   */
  trainingData: string;
  /**
   * A untyped set of parameters that are associated with this job
   */
  params: {
    [key: string]: unknown;
  };
  /**
   * Get cost associated with this job
   */
  cost?: number;
  /**
   * Get or set a custom cost value for this job
   */
  customCost?: number;
  /**
   * An application provided output of the current status of this job
   */
  output?: string | null;
  /**
   * The job type.
   */
  type?: string;
  /**
   * Rick: yeah i think for LoRA we need it to be 5-10 minutes.
   * lora training has this lame effect where it can't send updates while it is uploading... so we need to give it extra buffer
   */
  claimDuration?: string;
  $type: 'ImageResourceTrainingJob';
};

export type ImageResourceTrainingOutput = {
  /**
   * An array of epochs.
   */
  epochs: Array<EpochResult>;
  /**
   * Get wether the blobs are actually stored as assets
   * Assets are deprecated and require a different retrieval mechanism
   */
  storedAsAssets?: boolean | null;
};

/**
 * A workflow step for training image resources.
 */
export type ImageResourceTrainingStep = WorkflowStep & {
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob>;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
  input: ImageResourceTrainingInput;
  output?: ImageResourceTrainingOutput;
  $type: 'imageResourceTraining';
};

export type ImageResourceTrainingStepTemplate = WorkflowStepTemplate & {
  $type: 'imageResourceTraining';
  input: ImageResourceTrainingInput;
};

/**
 * Available image transformers.
 */
export type ImageTransformer = 'canny' | 'depthZoe' | 'softedgePidinet' | 'rembg';

export type Job = {
  $type: string;
  /**
   * A unique id for this job
   */
  id?: string;
  /**
   * The date when this job got created
   */
  createdAt?: string;
  /**
   * The date for when this job was set to expire
   */
  expireAt?: string | null;
  /**
   * A webhook to be invoked when the job receives a status update
   */
  webhook?: string | null;
  /**
   * A set of user defined properties that can be used to index and partition this job
   */
  properties?: {
    [key: string]: unknown;
  };
  /**
   * The type of this job as a string
   */
  type?: string;
  /**
   * Get a cost estimate for this job
   */
  cost?: number;
  /**
   * The max number of retries before we give up
   */
  maxRetryAttempt?: number;
  /**
   * Get or set a list of dependencies that this job has
   */
  dependencies?: {
    [key: string]: Array<DynamicAssignment> | null;
  };
  /**
   * Get or set the name of the consumer that issued this job
   */
  issuedBy?: string | null;
  /**
   * Get or set the version of this job, this is used to track changes to the job schema
   */
  version?: number;
  /**
   * The total duration that the job can be claimed
   */
  claimDuration?: string;
  /**
   * An internal property to mark that the job has been recovered. We use this to not fiddle with up/down counters as we may have missed other counters
   */
  recovered?: boolean;
};

/**
 * Available levels of job support.
 */
export type JobSupport = 'unsupported' | 'unavailable' | 'available';

/**
 * LLM prompt augmentaition capabilities.
 */
export type LLMPromptAugmentationCapabilities = {
  [key: string]: unknown;
};

export type LLMPromptAugmentationJob = Job & {
  /**
   * The primary model to use.
   */
  model: string;
  /**
   * The base prompt.
   */
  basePrompt?: string | null;
  /**
   * A list of prompts.
   */
  prompts?: Array<string>;
  /**
   * The temp.
   */
  temp?: number;
  /**
   * The type.
   */
  type?: string;
  $type: 'LLMPromptAugmentationJob';
};

/**
 * Available options for priority.
 */
export type Priority = 'high' | 'normal' | 'low';

export type ProblemDetails = {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  [key: string]: unknown | undefined;
};

/**
 * Details of processing statistics.
 */
export type ProcessingStatistics = {
  /**
   * The total number of jobs requested.
   */
  totalJobsRequested?: number;
  /**
   * The total cost of jobs requested.
   */
  totalCostRequested?: number;
  /**
   * The total number of successful jobs.
   */
  totalJobsSucceeded?: number;
  /**
   * The total cost of successful jobs.
   */
  totalCostSucceeded?: number;
  /**
   * The total number of rejected jobs.
   */
  totalJobsRejected?: number;
  /**
   * The total cost of rejected jobs.
   */
  totalCostRejected?: number;
  /**
   * The total number of late rejected jobs.
   */
  totalJobsLateRejected?: number;
  /**
   * The total cost of laterejected jobs.
   */
  totalCostLateRejected?: number;
  /**
   * The total number of expired jobs.
   */
  totalJobsExpired?: number;
  /**
   * The total cost of expired jobs.
   */
  totalCostExpired?: number;
  /**
   * The total number of failed jobs.
   */
  totalJobsFailed?: number;
  /**
   * The total cost of failed jobs.
   */
  totalCostFailed?: number;
  /**
   * The total number of completed jobs.
   */
  totalJobsCompleted?: number;
  /**
   * The total cost of completed jobs.
   */
  totalCostCompleted?: number;
};

/**
 * Details for a specific resource.
 */
export type ResourceInfo = {
  /**
   * An AIR ID for the resource.
   */
  air: string;
  /**
   * The resource size in bytes.
   */
  size: number;
  /**
   * A collection of hashes.
   */
  hashes: {
    [key: string]: string;
  };
  /**
   * An array of download urls.
   */
  downloadUrls: Array<string>;
  /**
   * The name of the resource.
   */
  resourceName?: string | null;
  /**
   * The name of the version.
   */
  versionName?: string | null;
  /**
   * A date time to invalidate at.
   */
  invalidateAt?: string | null;
};

/**
 * The available options for schedulers used in image generation.
 */
export type Scheduler =
  | 'eulerA'
  | 'euler'
  | 'lms'
  | 'heun'
  | 'dpM2'
  | 'dpM2A'
  | 'dpM2SA'
  | 'dpM2M'
  | 'dpmsde'
  | 'dpmFast'
  | 'dpmAdaptive'
  | 'lmsKarras'
  | 'dpM2Karras'
  | 'dpM2AKarras'
  | 'dpM2SAKarras'
  | 'dpM2MKarras'
  | 'dpmsdeKarras'
  | 'ddim'
  | 'plms'
  | 'uniPC'
  | 'undefined'
  | 'lcm'
  | 'ddpm'
  | 'deis';

/**
 * Details for a similarity search job.
 */
export type SimilaritySearchJob = Job & {
  /**
   * An AIR ID representing the primary model.
   */
  model: string;
  /**
   * A value for the NSFW filter.
   */
  nsfwFilter: string;
  /**
   * The prompt provided.
   */
  prompt: string;
  /**
   * A collection of parameters.
   */
  params: {
    [key: string]: unknown;
  };
  /**
   * A value representing the cost of the job.
   */
  cost?: number;
  /**
   * The job type.
   */
  type?: string;
  $type: 'SimilaritySearchJob';
};

/**
 * A subscription for pushed based notifications.
 */
export type Subscription = {
  /**
   * The webhook url.
   */
  webhook: string;
};

/**
 * Input for an text to image step.
 */
export type TextToImageInput = {
  /**
   * The number of batches to run.
   */
  quantity?: number;
  /**
   * The size of each batch.
   */
  batchSize?: number;
  /**
   * The AIR of the checkpoint model to use for generation.
   */
  model: string;
  /**
   * Get or set a associative list of additional networks. Use the AIR of the network as the key.
   */
  additionalNetworks?: {
    [key: string]: ImageJobNetworkParams;
  };
  /**
   * Get or set a associative list of ControlNets.
   */
  controlNets?: Array<ImageJobControlNet>;
  /**
   * The provided text prompt.
   */
  prompt?: string;
  /**
   * The provided negative text prompt.
   */
  negativePrompt?: string;
  scheduler?: Scheduler;
  /**
   * The number of steps for image generation.
   */
  steps?: number;
  /**
   * The CFG scale value for image generation.
   */
  cfgScale?: number;
  /**
   * The desired image width in pixels.
   */
  width: number;
  /**
   * The desired image height in pixels.
   */
  height: number;
  /**
   * The seed to use in image generation. Defaults to a random value if left unpopulated.
   */
  seed?: number;
  /**
   * The clip skip value for image generation.
   */
  clipSkip?: number;
};

/**
 * A text to image generation job.
 */
export type TextToImageJob = Job & {
  /**
   * An AIR representing the model to use.
   */
  model: string;
  params: ImageJobParams;
  /**
   * The hash for the output image.
   */
  imageHash: string;
  /**
   * Get or set a associative list of additional networks. Each network is identified by a hash code.
   */
  additionalNetworks?: {
    [key: string]: ImageJobNetworkParams;
  };
  /**
   * Get or set the URL where the image will be uploaded to.
   */
  destinationUrl?: string | null;
  /**
   * A value indicating whether to store the image as a blob or as a legacy image.
   */
  storeAsBlob?: boolean;
  /**
   * Get or set a list of control nets that should be applied with this textToImage job.
   */
  controlNets?: Array<ImageJobControlNet>;
  /**
   * A value representing the cost of the job.
   */
  cost?: number;
  /**
   * The duration for which this job can be claimed for.
   */
  claimDuration?: string;
  /**
   * The job type.
   */
  type?: string;
  $type: 'TextToImageJob';
};

/**
 * Contains slot information for an image generated by a TextToImageJob.
 */
export type TextToImageJobSlot = {
  /**
   * The hash for the image output.
   */
  imageHash: string;
  /**
   * The destination url for image upload.
   */
  destinationUrl: string;
};

/**
 * Represents the output of a TextToImage workflow step.
 */
export type TextToImageOutput = {
  /**
   * A collection of output images.
   */
  images: Array<Image>;
};

/**
 * A workflow step for text to image generations.
 */
export type TextToImageStep = WorkflowStep & {
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob>;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
  input: TextToImageInput;
  output?: TextToImageOutput;
  $type: 'textToImage';
};

export type TextToImageStepTemplate = WorkflowStepTemplate & {
  $type: 'textToImage';
  input: TextToImageInput;
};

export type TextToImageV2Job = Job & {
  /**
   * An AIR representing the model to use.
   */
  model: string;
  params: ImageJobParams;
  /**
   * Slots for the resulting image outputs.
   */
  slots: Array<TextToImageJobSlot>;
  /**
   * Get or set a associative list of additional networks. Each network is identified by a hash code
   */
  additionalNetworks?: {
    [key: string]: ImageJobNetworkParams;
  };
  /**
   * Get or set a list of control nets that should be applied with this textToImage job
   */
  controlNets?: Array<ImageJobControlNet>;
  /**
   * A value representing the cost of the job.
   */
  cost?: number;
  /**
   * The duration for which this job can be claimed for.
   */
  claimDuration?: string;
  /**
   * The job type.
   */
  type?: string;
  $type: 'TextToImageV2Job';
};

/**
 * Transaction information.
 */
export type TransactionInfo = {
  /**
   * The transaction amount.
   */
  amount: number;
  /**
   * The transaction ID.
   */
  id: string | null;
};

export type TranscodeInput = {
  sourceUrl: string;
  containerFormat?: ContainerFormat;
  width?: number;
  destinationUrl?: string | null;
};

export type TranscodeOutput = {
  /**
   * Gets the id of the blob that contains the media.
   */
  id: string;
  /**
   * Gets a value indicating whether the media is available.
   */
  available: boolean;
  /**
   * Gets a url that can be used to preview the media.
   */
  url?: string | null;
  /**
   * Get when the url is set to expire
   */
  urlExpiresAt?: string | null;
  /**
   * Get the id of the job that is associated with this media.
   */
  jobId: string;
};

export type TranscodeStep = WorkflowStep & {
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob>;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
  input: TranscodeInput;
  output?: TranscodeOutput;
  $type: 'transcode';
};

export type TranscodeStepTemplate = WorkflowStepTemplate & {
  $type: 'transcode';
  input: TranscodeInput;
};

/**
 * An request for updating a workflow.
 */
export type UpdateWorkflowRequest = {
  status?: UpdateWorkflowStatus;
  /**
   * An optional set of new properties to set on the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Available statuses for updating workflows.
 */
export type UpdateWorkflowStatus = 'canceled';

/**
 * Details of a worker's capabilities.
 */
export type WorkerCapabilities = {
  image?: WorkerImageCapabilities;
  media?: WorkerMediaCapabilities;
  modelManagement?: WorkerModelPreparationCapabilities;
  configurationManagement?: WorkerConfigurationCapabilities;
  similaritySearch?: WorkerSimilaritySearchCapabilities;
  llmPromptAugmentation?: LLMPromptAugmentationCapabilities;
};

/**
 * Details of a worker's configuration capabilities.
 */
export type WorkerConfigurationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details for a particular worker.
 */
export type WorkerDetails = {
  /**
   * The worker's ID.
   */
  id: string;
  /**
   * The worker's name.
   */
  name: string;
  /**
   * The worker's active job count.
   */
  activeJobs?: number;
  /**
   * The number of jobs in the worker's queue.
   */
  queueSize?: number;
  /**
   * The total cost of job's in the worker's queue.
   */
  queueDepth?: number;
  /**
   * The worker's start date / time.
   */
  startDate?: string;
  /**
   * The worker's last request date / time.
   */
  lastRequestDate?: string | null;
  /**
   * The worker's expiration date / time.
   */
  expirationDate?: string | null;
  statistics?: ProcessingStatistics;
  /**
   * The worker's succeeded job throughput rate.
   */
  succeededThroughputRate?: number;
  /**
   * The worker's failed job throughput rate.
   */
  failedThroughputRate?: number;
  /**
   * The worker's idle rate.
   */
  idleRate?: number;
  /**
   * The date / time of the worker's last successfully completed job.
   */
  lastSuccesfullyCompletedJobDate?: string | null;
  /**
   * The date / time of the worker's last job update.
   */
  lastJobUpdateDate?: string | null;
  /**
   * The date / time that the worker's subscription was set.
   */
  subscriptionSetDate?: string | null;
  /**
   * The date / time that the worker was quarantined.
   */
  quarantineDate?: string | null;
  /**
   * The rate at which this worker has been downloading
   */
  resourceDownloadRate?: number;
  /**
   * The rate at which this worker has been evicting resources
   */
  resourceEvictionRate?: number;
};

/**
 * Details of a worker's image capabilities.
 */
export type WorkerImageCapabilities = {
  textToImage?: WorkerImageTextToImageCapabilities;
  imageToImage?: WorkerImageImageToImageCapabilities;
  transform?: WorkerImageTransformCapabilities;
  resourceTraining?: WorkerImageResourceTrainingCapabilities;
  embedding?: WorkerImageEmbeddingCapabilities;
};

/**
 * Details of a worker's image embedding capabilities.
 */
export type WorkerImageEmbeddingCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's image to image capabilities.
 */
export type WorkerImageImageToImageCapabilities = {
  /**
   * The worker's maximum supported image size for image to image (squared).
   */
  size?: number;
  /**
   * A list of schedulers the worker supports for image to image.
   */
  schedulers?: Array<Scheduler>;
  /**
   * The number of ControlNets the worker supports for image to image (at once).
   */
  controlNet?: number;
  /**
   * Indicates whether the worker supports inpaiting.
   */
  inpainting?: boolean;
};

/**
 * Details of a worker's image resource training capabilities.
 */
export type WorkerImageResourceTrainingCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's text to image capabilities.
 */
export type WorkerImageTextToImageCapabilities = {
  /**
   * The worker's maximum supported image size for text to image (squared).
   */
  size?: number;
  /**
   * A list of schedulers the worker supports for text to image.
   */
  schedulers?: Array<Scheduler>;
  /**
   * The number of ControlNets the worker supports for text to image (at once).
   */
  controlNet?: number;
};

/**
 * Details of a worker's image transform capabilities.
 */
export type WorkerImageTransformCapabilities = {
  /**
   * A list of supported image transformers.
   */
  transformers?: Array<ImageTransformer>;
};

/**
 * Details of a worker's media capabilities.
 */
export type WorkerMediaCapabilities = {
  wdTagging?: WorkerMediaWDTaggingCapabilities;
  comfy?: WorkerMediaComfyCapabilities;
  tagging?: WorkerMediaTaggingCapabilities;
  movieRating?: WorkerMediaMovieRatingCapabilities;
  transcode?: WorkerMediaTranscodeCapabilities;
};

/**
 * Details of a worker's media comfy capabilities.
 */
export type WorkerMediaComfyCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media movie rating capabilities.
 */
export type WorkerMediaMovieRatingCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media tagging capabilities.
 */
export type WorkerMediaTaggingCapabilities = {
  [key: string]: unknown;
};

export type WorkerMediaTranscodeCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media WD tagging capabilities.
 */
export type WorkerMediaWDTaggingCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's model preparation capabilities.
 */
export type WorkerModelPreparationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's registration.
 */
export type WorkerRegistration = {
  /**
   * The worker's name.
   */
  name: string;
  /**
   * A hash set of resource types the worker can retrieve on demand.
   */
  onDemandResourceTypes?: Array<string>;
  capabilities?: WorkerCapabilities;
  subscription?: Subscription;
  type?: WorkerType;
  /**
   * The number of requests the worker can handle at once.
   */
  concurrentLimit?: number;
  /**
   * A collection of ecosystems the worker supports.
   */
  ecosystems?: {
    [key: string]: EcosystemElement;
  };
  /**
   * A collection of information about the availability of particular resources on this worker.
   */
  resources?: {
    [key: string]: WorkerResourceStatus;
  };
  /**
   * The name of the closest cache level that this worker can interact with.
   */
  cacheLevel?: string | null;
  /**
   * The max queue size before the worker stops accepting requests that require cold swapping.
   */
  maxColdSwapQueueSize?: number | null;
  /**
   * The max size in Mb of downloads that can be pending.
   */
  maxPendingResourceSize?: number | null;
  /**
   * A value indicating if worker should consume jobs that are not yet available.
   */
  consumeUnavailableJobs?: boolean;
  /**
   * An optional identifier unique to this worker.
   */
  nodeIdentifier?: string | null;
};

/**
 * Options for representing the status for a resource on a worker.
 */
export type WorkerResourceAvailability =
  | 'unknown'
  | 'unsupported'
  | 'unavailable'
  | 'available'
  | 'providerUnsupported';

/**
 * Details for the status of a resource on a particular worker.
 */
export type WorkerResourceStatus = {
  availability: WorkerResourceAvailability;
  /**
   * The cost associated with this resource.
   */
  cost?: number;
};

/**
 * Details of a worker's similarity search capabilities.
 */
export type WorkerSimilaritySearchCapabilities = {
  [key: string]: unknown;
};

/**
 * Available values for worker type.
 */
export type WorkerType = 'normal' | 'deferred';

/**
 * Details of a workflow.
 */
export type Workflow = {
  /**
   * The ID for the workflow.
   */
  id?: string | null;
  /**
   * The date / time the workflow was created.
   */
  createdAt?: string;
  /**
   * An array of transactions on this workflow.
   */
  transactions?: Array<TransactionInfo> | null;
  /**
   * A collection of user defined metadata for the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  status?: WorkflowStatus;
  /**
   * The date / time the workflow was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the workflow was completed. Null if not yet complete.
   */
  completedAt?: string | null;
  /**
   * The steps for the workflow.
   */
  steps?: Array<WorkflowStep>;
  /**
   * An array of callback details for the workflow.
   */
  callbacks?: Array<WorkflowCallback>;
};

/**
 * Details of a callback setup for a workflow.
 */
export type WorkflowCallback = {
  /**
   * The url for the callback.
   */
  url: string;
  /**
   * An array of event types to send to the callback.
   */
  type: Array<
    | 'workflow:*'
    | 'workflow:unassigned'
    | 'workflow:processing'
    | 'workflow:succeeded'
    | 'workflow:failed'
    | 'workflow:expired'
    | 'workflow:canceled'
    | 'step:*'
    | 'step:unassigned'
    | 'step:processing'
    | 'step:succeeded'
    | 'step:failed'
    | 'step:expired'
    | 'step:canceled'
    | 'job:*'
    | 'job:unassigned'
    | 'job:processing'
    | 'job:succeeded'
    | 'job:failed'
    | 'job:expired'
    | 'job:canceled'
  >;
};

/**
 * Details of a workflow event.
 */
export type WorkflowEvent = {
  /**
   * The ID that represents the corresponding workflow.
   */
  workflowId: string;
  status: WorkflowStatus;
  $type?: string | null;
};

/**
 * Values available to represent workflow status.
 */
export type WorkflowStatus =
  | 'unassigned'
  | 'preparing'
  | 'scheduled'
  | 'processing'
  | 'succeeded'
  | 'failed'
  | 'expired'
  | 'canceled';

/**
 * Details of a workflow step.
 */
export type WorkflowStep = {
  $type: string;
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob>;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
};

/**
 * Details of a workflow step event.
 */
export type WorkflowStepEvent = {
  /**
   * The workflow ID.
   */
  workflowId: string;
  /**
   * The workflow step's name.
   */
  stepName: string;
  status: WorkflowStatus;
  $type?: string | null;
};

/**
 * Details of a job produced by a workflow step.
 */
export type WorkflowStepJob = {
  /**
   * The job's ID.
   */
  id: string;
  /**
   * The job's cost.
   */
  cost: number;
  status?: WorkflowStatus;
  /**
   * The date / time the job started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the job completed. Null if not yet completed.
   */
  completedAt?: string | null;
  queuePosition?: WorkflowStepJobQueuePosition;
};

/**
 * Details of a workflow step job event.
 */
export type WorkflowStepJobEvent = {
  /**
   * The workflow ID.
   */
  workflowId: string;
  /**
   * The step's name.
   */
  stepName: string;
  /**
   * The job's ID.
   */
  jobId: string;
  status: WorkflowStatus;
  $type?: string | null;
};

/**
 * Details of the workflow step job's queue position.
 */
export type WorkflowStepJobQueuePosition = {
  support?: JobSupport;
  /**
   * The number of preceding jobs in the queue.
   */
  precedingJobs?: number | null;
  /**
   * An estimated date / time for when the job will start.
   */
  startAt?: string | null;
  /**
   * An estimated date / time for when the job will complete.
   */
  completeAt?: string | null;
};

/**
 * Details of a workflow step template.
 */
export type WorkflowStepTemplate = {
  /**
   * The type of step the template represents.
   */
  $type: string;
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
};

/**
 * Details of a requested workflow.
 */
export type WorkflowTemplate = {
  /**
   * A colletion of user defined metadata that can be used to store additional information about the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * An array of steps that compose this workflow.
   */
  steps: Array<WorkflowStepTemplate>;
  /**
   * An array of callbacks to be triggered during the lifetime of the workflow.
   */
  callbacks?: Array<WorkflowCallback>;
};

export type $OpenApiTs = {
  '/v2/consumer/blobs/{blobId}': {
    get: {
      req: {
        /**
         * The blob ID to retrieve.
         */
        blobId: string;
      };
      res: {
        /**
         * Unauthorized
         */
        401: ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations': {
    post: {
      req: {
        /**
         * The details of the configuration being created.
         */
        requestBody?: ConfigurationOptions;
      };
      res: {
        /**
         * Success
         */
        200: CreateConfigurationResult;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
      };
    };
    get: {
      res: {
        /**
         * Success
         */
        200: ConfigurationStatus;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations/{configurationId}/options': {
    get: {
      req: {
        /**
         * The ID of the configuration whose options are being requested.
         */
        configurationId: string;
      };
      res: {
        /**
         * Success
         */
        200: ConfigurationOptions;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations/{configurationId}': {
    delete: {
      req: {
        /**
         * The ID of the configuration to delete.
         */
        configurationId: string;
      };
      res: {
        /**
         * Success
         */
        200: unknown;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/resources/{air}': {
    get: {
      req: {
        /**
         * A unique ID for the resource being requested. See https://developer.civitai.com/docs/getting-started/ai-resource-identifier for more info on AIRs.
         */
        air: string;
      };
      res: {
        /**
         * Success
         */
        200: ResourceInfo;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
    delete: {
      req: {
        /**
         * A unique ID for the resource being requested. See https://developer.civitai.com/docs/getting-started/ai-resource-identifier for more info on AIRs.
         */
        air: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Bad Request
         */
        400: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/jobs': {
    get: {
      req: {
        claim?: boolean;
        take?: number;
        wait?: number | null;
        workerId: string;
      };
      res: {
        /**
         * Success
         */
        200: Array<Job>;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers': {
    post: {
      req: {
        /**
         * The registration specifying the details of the worker to be created.
         */
        requestBody?: WorkerRegistration;
      };
      res: {
        /**
         * Created
         */
        201: CreateWorkerResult;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
      };
    };
    get: {
      res: {
        /**
         * Success
         */
        200: Array<WorkerDetails>;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}': {
    get: {
      req: {
        /**
         * The ID for the requested worker.
         */
        workerId: string;
      };
      res: {
        /**
         * Success
         */
        200: WorkerDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
    delete: {
      req: {
        /**
         * The ID for the worker to be deleted.
         */
        workerId: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/registration': {
    get: {
      req: {
        /**
         * The ID of the worker whose registration is being requested.
         */
        workerId: string;
      };
      res: {
        /**
         * Success
         */
        200: WorkerRegistration;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
    put: {
      req: {
        /**
         * The registration details to update on the worker's registration.
         */
        requestBody?: WorkerRegistration;
        /**
         * The ID for the worker whose registration is being updated.
         */
        workerId: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/registration/resources': {
    patch: {
      req: {
        /**
         * A dictionary of resource AIRs and their corresponding status for on that worker.
         */
        requestBody?: {
          [key: string]: WorkerResourceStatus;
        };
        /**
         * The ID for the worker whose registration resources are being patched.
         */
        workerId: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Forbidden
         */
        403: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows': {
    post: {
      req: {
        requestBody?: WorkflowTemplate;
        /**
         * Whether to wait for the workflow to complete before returning or to return immediately
         * The request may return a 202 if the clients waits for the workflow to complete and the workflow does not complete within the requested timeout.
         * In which case the client should use the token to query the status of the workflow.
         */
        wait?: number;
        /**
         * Whether to actually submit the workflow or return an estimate on what would happen upon submission
         */
        whatif?: boolean;
      };
      res: {
        /**
         * Success
         */
        200: Workflow;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
      };
    };
    get: {
      req: {
        /**
         * An optional cursor to continue querying workflows from a previous query.
         */
        cursor?: string;
        /**
         * The type of job to filter on.
         */
        jobType?: Array<string>;
        /**
         * How many workflows to return
         */
        take?: number;
      };
      res: {
        /**
         * Success
         */
        200: CursedArrayOfTelemetryCursorAndWorkflow;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows/{workflowId}': {
    get: {
      req: {
        /**
         * Whether to wait for the workflow to complete before returning or to return immediately
         * The request may return a 202 if the clients waits for the workflow to complete and the workflow does not complete within the requested timeout.
         * In which case the client should use the token to query the status of the workflow.
         */
        wait?: boolean;
        /**
         * The id of the workflow to get status for
         */
        workflowId: string;
      };
      res: {
        /**
         * Success
         */
        200: Workflow;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
    put: {
      req: {
        /**
         * The details to update on the workflow.
         */
        requestBody?: UpdateWorkflowRequest;
        /**
         * The id of the request to update.
         */
        workflowId: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Bad Request
         */
        400: ProblemDetails;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
    delete: {
      req: {
        /**
         * The id of the workflow to delete.
         */
        workflowId: string;
      };
      res: {
        /**
         * No Content
         */
        204: void;
        /**
         * Unauthorized
         */
        401: ProblemDetails;
        /**
         * Not Found
         */
        404: ProblemDetails;
      };
    };
  };
};
