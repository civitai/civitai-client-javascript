// This file is auto-generated by @hey-api/openapi-ts

export type AgeClassificationInput = {
  /**
   * An optional model to use for age classification. If not provided, the default model will determined by the worker
   */
  model?: string | null;
  /**
   * The URL of the media to classify
   */
  mediaUrl: string;
};

export type AgeClassificationJob = Job & {
  model?: string | null;
  mediaUrl: string;
  destinationBlobKey: string;
  destinationUrl: string;
  failOnMinorDetected: boolean;
  readonly claimDuration?: string;
  readonly type?: string;
} & {
  $type: 'ageClassification';
};

export type $type = 'ageClassification';

export const $type = {
  AGE_CLASSIFICATION: 'ageClassification',
} as const;

export type AgeClassificationOutput = {
  labels: {
    [key: string]: Array<AgeClassifierLabel>;
  };
  hasMinor: boolean;
  prediction: AgeClassificationPrediction;
};

export type AgeClassificationPrediction = 'pass' | 'fail';

export const AgeClassificationPrediction = {
  PASS: 'pass',
  FAIL: 'fail',
} as const;

export type AgeClassificationStep = WorkflowStep & {
  input: AgeClassificationInput;
  output?: AgeClassificationOutput;
} & {
  $type: 'ageClassification';
};

export type AgeClassificationStepTemplate = WorkflowStepTemplate & {
  input: AgeClassificationInput;
} & {
  $type: 'ageClassification';
};

export type AgeClassifierLabel = {
  age: string;
  isMinor: boolean;
  boundingBox: Array<number>;
};

export type BatchOCRSafetyClassificationInput = {
  mediaUrls: Array<string>;
};

export type BatchOCRSafetyClassificationJob = Job & {
  mediaUrls: Array<string>;
  readonly type?: string;
} & {
  $type: 'batchOCRSafetyClassification';
};

export type $type2 = 'batchOCRSafetyClassification';

export const $type2 = {
  BATCH_OCRSAFETY_CLASSIFICATION: 'batchOCRSafetyClassification',
} as const;

export type BatchOCRSafetyClassificationOutput = {
  results: Array<BatchOCRSafetyClassificationResult>;
};

export type BatchOCRSafetyClassificationResult = {
  mediaUrl: string;
  classification: string;
  text?: string | null;
};

export type BatchOCRSafetyClassificationStep = WorkflowStep & {
  input: BatchOCRSafetyClassificationInput;
  output?: BatchOCRSafetyClassificationOutput;
} & {
  $type: 'batchOCRSafetyClassification';
};

export type BatchOCRSafetyClassificationStepTemplate = WorkflowStepTemplate & {
  input: BatchOCRSafetyClassificationInput;
} & {
  $type: 'batchOCRSafetyClassification';
};

/**
 * Represents a blob that gets produced as part of a specific job
 */
export type Blob = {
  type: string;
  /**
   * Gets the id of the blob that contains this image.
   */
  id: string;
  /**
   * Gets a value indicating whether the blob is available.
   */
  available: boolean;
  /**
   * Gets a url that can be used to preview the blob.
   */
  url?: string | null;
  /**
   * Get when the url is set to expire
   */
  urlExpiresAt?: string | null;
  /**
   * Get the id of the job that is associated with this blob.
   */
  jobId?: string | null;
  nsfwLevel?: NSFWLevel;
};

export type BuzzClientAccount = 'user' | 'generation';

export const BuzzClientAccount = {
  USER: 'user',
  GENERATION: 'generation',
} as const;

export type ComfyInput = {
  /**
   * Get the comfy workflow that needs to be executed
   */
  comfyWorkflow: {
    [key: string]: ComfyNode;
  };
  /**
   * The number of jobs to start with this workflow.
   */
  quantity?: number;
  /**
   * External metadata that will be stored with the image
   */
  imageMetadata?: string | null;
};

export type ComfyJob = Job & {
  /**
   * A untyped set of parameters that are associated with this job
   */
  params: {
    [key: string]: ComfyNode;
  };
  resources?: Array<string> | null;
  /**
   * Slots for the resulting blob outputs.
   */
  slots: Array<ComfyJobSlot>;
  /**
   * Get or set additional metadata that will be embedded with generated images
   */
  imageMetadata?: string | null;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'comfy';
};

export type $type3 = 'comfy';

export const $type3 = {
  COMFY: 'comfy',
} as const;

/**
 * Contains slot information for a blob generated by a ComfyJob.
 */
export type ComfyJobSlot = {
  /**
   * The hash for the blob output.
   */
  blobKey: string;
  /**
   * The destination url for blob upload.
   */
  destinationUrl: string;
};

export type ComfyNode = {
  classType: string;
  meta?: {
    [key: string]: string;
  } | null;
  isChanged?: string | null;
  inputs: {
    [key: string]: string | number | boolean | [number, number];
  };
};

export type ComfyOutput = {
  /**
   * Get a list of blobs that got generated by this comfy workflow step.
   */
  blobs?: Array<Blob>;
};

export type ComfyStep = WorkflowStep & {
  input: ComfyInput;
  output?: ComfyOutput;
} & {
  $type: 'comfy';
};

export type ComfyStepTemplate = WorkflowStepTemplate & {
  input: ComfyInput;
} & {
  $type: 'comfy';
};

export type ComfyVideoGenInput = VideoGenInput & {
  model?: string;
  negativePrompt?: string | null;
  sampler?:
    | 'euler'
    | 'euler_cfg_pp'
    | 'euler_ancestral'
    | 'euler_ancestral_cfg_pp'
    | 'heun'
    | 'heunpp2'
    | 'dpm_2'
    | 'dpm_2_ancestral'
    | 'lms'
    | 'dpm_fast'
    | 'dpm_adaptive'
    | 'dpmpp_2s_ancestral'
    | 'dpmpp_2s_ancestral_cfg_pp'
    | 'dpmpp_sde'
    | 'dpmpp_sde_gpu'
    | 'dpmpp_2m'
    | 'dpmpp_2m_cfg_pp'
    | 'dpmpp_2m_sde'
    | 'dpmpp_2m_sde_gpu'
    | 'dpmpp_3m_sde'
    | 'dpmpp_3m_sde_gpu'
    | 'ddpm'
    | 'lcm'
    | 'ipndm'
    | 'ipndm_v'
    | 'deis';
  cfgScale?: number;
  width?: number;
  height?: number;
  frameRate?: number;
  duration?: number;
  seed?: number | null;
  steps?: number;
} & {
  engine: 'comfy';
};

export type sampler =
  | 'euler'
  | 'euler_cfg_pp'
  | 'euler_ancestral'
  | 'euler_ancestral_cfg_pp'
  | 'heun'
  | 'heunpp2'
  | 'dpm_2'
  | 'dpm_2_ancestral'
  | 'lms'
  | 'dpm_fast'
  | 'dpm_adaptive'
  | 'dpmpp_2s_ancestral'
  | 'dpmpp_2s_ancestral_cfg_pp'
  | 'dpmpp_sde'
  | 'dpmpp_sde_gpu'
  | 'dpmpp_2m'
  | 'dpmpp_2m_cfg_pp'
  | 'dpmpp_2m_sde'
  | 'dpmpp_2m_sde_gpu'
  | 'dpmpp_3m_sde'
  | 'dpmpp_3m_sde_gpu'
  | 'ddpm'
  | 'lcm'
  | 'ipndm'
  | 'ipndm_v'
  | 'deis';

export const sampler = {
  EULER: 'euler',
  EULER_CFG_PP: 'euler_cfg_pp',
  EULER_ANCESTRAL: 'euler_ancestral',
  EULER_ANCESTRAL_CFG_PP: 'euler_ancestral_cfg_pp',
  HEUN: 'heun',
  HEUNPP2: 'heunpp2',
  DPM_2: 'dpm_2',
  DPM_2_ANCESTRAL: 'dpm_2_ancestral',
  LMS: 'lms',
  DPM_FAST: 'dpm_fast',
  DPM_ADAPTIVE: 'dpm_adaptive',
  DPMPP_2S_ANCESTRAL: 'dpmpp_2s_ancestral',
  DPMPP_2S_ANCESTRAL_CFG_PP: 'dpmpp_2s_ancestral_cfg_pp',
  DPMPP_SDE: 'dpmpp_sde',
  DPMPP_SDE_GPU: 'dpmpp_sde_gpu',
  DPMPP_2M: 'dpmpp_2m',
  DPMPP_2M_CFG_PP: 'dpmpp_2m_cfg_pp',
  DPMPP_2M_SDE: 'dpmpp_2m_sde',
  DPMPP_2M_SDE_GPU: 'dpmpp_2m_sde_gpu',
  DPMPP_3M_SDE: 'dpmpp_3m_sde',
  DPMPP_3M_SDE_GPU: 'dpmpp_3m_sde_gpu',
  DDPM: 'ddpm',
  LCM: 'lcm',
  IPNDM: 'ipndm',
  IPNDM_V: 'ipndm_v',
  DEIS: 'deis',
} as const;

export type engine = 'comfy';

export const engine = {
  COMFY: 'comfy',
} as const;

export type ComfyVideoGenJob = Job & {
  model: string;
  prompt: string;
  negativePrompt?: string | null;
  cfgScale?: number;
  destinationUrl: string;
  sampler?: string;
  width?: number;
  height?: number;
  frameRate?: number;
  length?: number;
  seed?: number;
  steps?: number;
  readonly claimDuration?: string;
  readonly type?: string;
} & {
  $type: 'comfyVideoGen';
};

export type $type4 = 'comfyVideoGen';

export const $type4 = {
  COMFY_VIDEO_GEN: 'comfyVideoGen',
} as const;

export type ConfigurationOptions = {
  /**
   * Get or set the priority of this configuration if multiple configurations apply to the same worker
   */
  priority?: number;
  selector: Expression;
  /**
   * Get or set the specification associated with this configuration
   */
  spec: unknown;
};

export type ConfigurationStatus = {
  configurationId: string;
  assigned?: number;
  targeted?: number;
  applied?: number;
};

export type ContainerFormat = 'mp4' | 'webM';

export const ContainerFormat = {
  MP4: 'mp4',
  WEB_M: 'webM',
} as const;

export type CreateConfigurationResult = {
  configurationId: string;
};

export type CreateWorkerResult = {
  workerId: string;
};

export type CursedArrayOfTelemetryCursorAndWorkflow = {
  next: string;
  items: Array<Workflow>;
};

export type DownloadSource = 'default' | 'tigris';

export const DownloadSource = {
  DEFAULT: 'default',
  TIGRIS: 'tigris',
} as const;

export type DynamicAssignment = {
  fromPath: string;
  toPath: string;
  defaultValue?: unknown;
};

/**
 * Represents the input information needed for the Echo workflow step.
 */
export type EchoInput = {
  /**
   * The message to be returned in the output.
   */
  message: string;
};

/**
 * Represents the output information returned from the Echo workflow step.
 */
export type EchoOutput = {
  /**
   * The message to be returned.
   */
  message: string;
};

/**
 * A workflow step that takes a message string and retuns it.
 */
export type EchoStep = WorkflowStep & {
  input: EchoInput;
  output?: EchoOutput;
} & {
  $type: 'echo';
};

export type $type5 = 'echo';

export const $type5 = {
  ECHO: 'echo',
} as const;

export type EchoStepTemplate = WorkflowStepTemplate & {
  input: EchoInput;
} & {
  $type: 'echo';
};

export type EcosystemElement = {
  [key: string]: EcosystemElement;
};

/**
 * An epock result.
 */
export type EpochResult = {
  epochNumber?: number;
  /**
   * Get the name of the generated epoch assets
   */
  blobName: string;
  /**
   * Get the total size in bytes of the asset
   */
  blobSize?: number | null;
  /**
   * Get a list of the names of the blobs that represent sample images
   */
  sampleImages?: Array<string>;
  /**
   * A presigned url that points to the epoch file
   */
  blobUrl: string;
};

export type Expression = {
  [key: string]: unknown;
};

export type FileFormat =
  | 'unknown'
  | 'safeTensor'
  | 'pickleTensor'
  | 'diffusers'
  | 'coreML'
  | 'onnx';

export const FileFormat = {
  UNKNOWN: 'unknown',
  SAFE_TENSOR: 'safeTensor',
  PICKLE_TENSOR: 'pickleTensor',
  DIFFUSERS: 'diffusers',
  CORE_ML: 'coreML',
  ONNX: 'onnx',
} as const;

export type FluxDevFastImageResourceTrainingInput = ImageResourceTrainingInput & {
  [key: string]: unknown;
} & {
  engine: 'flux-dev-fast';
};

export type engine2 = 'flux-dev-fast';

export const engine2 = {
  FLUX_DEV_FAST: 'flux-dev-fast',
} as const;

export type GateJob = Job & {
  readonly type?: string;
} & {
  $type: 'gate';
};

export type $type6 = 'gate';

export const $type6 = {
  GATE: 'gate',
} as const;

export type HaiperVideoGenAspectRatio = '16:9' | '4:3' | '1:1' | '9:16' | '3:4';

export const HaiperVideoGenAspectRatio = {
  _16_9: '16:9',
  _4_3: '4:3',
  _1_1: '1:1',
  _9_16: '9:16',
  _3_4: '3:4',
} as const;

export type HaiperVideoGenCameraMovement =
  | 'none'
  | 'panRight'
  | 'panLeft'
  | 'tiltUp'
  | 'tiltDown'
  | 'zoomIn'
  | 'zoomOut';

export const HaiperVideoGenCameraMovement = {
  NONE: 'none',
  PAN_RIGHT: 'panRight',
  PAN_LEFT: 'panLeft',
  TILT_UP: 'tiltUp',
  TILT_DOWN: 'tiltDown',
  ZOOM_IN: 'zoomIn',
  ZOOM_OUT: 'zoomOut',
} as const;

export type HaiperVideoGenInput = VideoGenInput & {
  negativePrompt?: string | null;
  cameraMovement?: HaiperVideoGenCameraMovement;
  seed?: number;
  duration?: 2 | 4 | 8;
  aspectRatio?: HaiperVideoGenAspectRatio;
  model?: HaiperVideoGenModel;
  resolution?: 720 | 1080 | 2160;
  enablePromptEnhancer?: boolean;
  sourceImage?: SourceImage;
} & {
  engine: 'haiper';
};

export type duration = 2 | 4 | 8;

export const duration = {
  _2: 2,
  _4: 4,
  _8: 8,
} as const;

export type resolution = 720 | 1080 | 2160;

export const resolution = {
  _720: 720,
  _1080: 1080,
  _2160: 2160,
} as const;

export type engine3 = 'haiper';

export const engine3 = {
  HAIPER: 'haiper',
} as const;

export type HaiperVideoGenJob = Job & {
  mediaHash: string;
  prompt: string;
  negativePrompt?: string | null;
  cameraMovement?: HaiperVideoGenCameraMovement;
  seed?: number;
  duration?: 2 | 4 | 8;
  aspectRatio?: HaiperVideoGenAspectRatio;
  destinationUrl: string;
  sourceImageUrl?: string | null;
  model?: HaiperVideoGenModel;
  resolution?: number;
  enablePromptEnhancer?: boolean;
  readonly claimDuration?: string;
  readonly type?: string;
} & {
  $type: 'haiper';
};

export type $type7 = 'haiper';

export const $type7 = {
  HAIPER: 'haiper',
} as const;

export type HaiperVideoGenModel = 'v1_5' | 'v2';

export const HaiperVideoGenModel = {
  V1_5: 'v1_5',
  V2: 'v2',
} as const;

export type HaiperVideoGenOutput = VideoGenOutput & {
  progress?: number | null;
  externalTOSViolation?: boolean | null;
  message?: string | null;
};

export type HumanoidImageMaskCategory = 'dresses' | 'upperBody' | 'lowerBody';

export const HumanoidImageMaskCategory = {
  DRESSES: 'dresses',
  UPPER_BODY: 'upperBody',
  LOWER_BODY: 'lowerBody',
} as const;

export type HumanoidImageMaskInput = {
  imageUrl: string;
  category: HumanoidImageMaskCategory;
};

export type HumanoidImageMaskJob = Job & {
  imageUrl: string;
  category: HumanoidImageMaskCategory;
  destinationBlobKey: string;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'humanoidImageMask';
};

export type $type8 = 'humanoidImageMask';

export const $type8 = {
  HUMANOID_IMAGE_MASK: 'humanoidImageMask',
} as const;

export type HumanoidImageMaskOutput = {
  blob: Blob;
};

export type HumanoidImageMaskStep = WorkflowStep & {
  input: HumanoidImageMaskInput;
  output?: HumanoidImageMaskOutput;
} & {
  $type: 'humanoidImageMask';
};

export type HumanoidImageMaskStepTemplate = WorkflowStepTemplate & {
  input: HumanoidImageMaskInput;
} & {
  $type: 'humanoidImageMask';
};

export type ImageEmbeddingJob = Job & {
  imageUrl: string;
  readonly type?: string;
} & {
  $type: 'imageEmbedding';
};

export type $type9 = 'imageEmbedding';

export const $type9 = {
  IMAGE_EMBEDDING: 'imageEmbedding',
} as const;

/**
 * Information for a controlnet provided for a text to image input.
 */
export type ImageJobControlNet = {
  preprocessor?: ImageTransformer;
  /**
   * A value representing the weight applied to the ControlNet.
   */
  weight?: number;
  /**
   * A value representing the start step selected for the ControlNet.
   */
  startStep?: number;
  /**
   * A value representing the end step selected for the ControlNet.
   */
  endStep?: number;
};

export type ImageJobNetworkParams = {
  /**
   * In case of Lora and LoCon, set the strength of the network
   */
  strength?: number | null;
  /**
   * In case of a TextualInversion, set the trigger word of the network
   */
  triggerWord?: string | null;
  /**
   * A legacy type set by the consumer
   */
  type?: string | null;
};

/**
 * Parameters for a text to image step.
 */
export type ImageJobParams = {
  /**
   * The prompt for the text to image generation.
   */
  prompt?: string | null;
  /**
   * The negative prompt for the text to image generation.
   */
  negativePrompt?: string | null;
  scheduler?: Scheduler;
  /**
   * The number of steps for the text to image generation.
   */
  steps?: number;
  /**
   * The CFG scale value for the text to image generation.
   */
  cfgScale?: number | null;
  /**
   * The width for the image to be generated in pixels.
   */
  width: number;
  /**
   * The height for the image to be generated in pixels.
   */
  height: number;
  /**
   * The seed for the text to image generation.
   */
  seed?: number;
  /**
   * The clip skip value for the text to image generation.
   */
  clipSkip?: number;
};

export type ImageResouceTrainingModerationStatus =
  | 'evaluating'
  | 'underReview'
  | 'approved'
  | 'rejected';

export const ImageResouceTrainingModerationStatus = {
  EVALUATING: 'evaluating',
  UNDER_REVIEW: 'underReview',
  APPROVED: 'approved',
  REJECTED: 'rejected',
} as const;

/**
 * Input for an image resource training step.
 */
export type ImageResourceTrainingInput = {
  engine: string;
  /**
   * The primary model to train upon.
   */
  model: string;
  /**
   * A url referring data to use in training.
   */
  trainingData: string;
  /**
   * The number of images embedded in this training data. This is used to calculate the cost of training.
   */
  trainingDataImagesCount: number;
  /**
   * The desired lora name.
   */
  loraName?: string;
  /**
   * A selection of sample prompts.
   */
  samplePrompts?: Array<string>;
};

export type ImageResourceTrainingJob = Job & {
  /**
   * An AIR representing the model to use.
   */
  model: string;
  /**
   * A url referring data that needs to be trained upon
   */
  trainingData: string;
  /**
   * A untyped set of parameters that are associated with this job
   */
  params: {
    [key: string]: unknown;
  };
  /**
   * An application provided output of the current status of this job
   */
  output?: string | null;
  /**
   * The engine that should be used for training
   */
  engine?: string | null;
  /**
   * The job type.
   */
  readonly type?: string;
  /**
   * Rick: yeah i think for LoRA we need it to be 5-10 minutes.
   * lora training has this lame effect where it can't send updates while it is uploading... so we need to give it extra buffer
   */
  readonly claimDuration?: string;
} & {
  $type: 'imageResourceTraining';
};

export type $type10 = 'imageResourceTraining';

export const $type10 = {
  IMAGE_RESOURCE_TRAINING: 'imageResourceTraining',
} as const;

export type ImageResourceTrainingOutput = {
  moderationStatus: ImageResouceTrainingModerationStatus;
  /**
   * An array of epochs.
   */
  epochs: Array<EpochResult>;
  /**
   * The selected prompts for sample images
   */
  sampleImagesPrompts: Array<string>;
  /**
   * Get wether the blobs are actually stored as assets
   * Assets are deprecated and require a different retrieval mechanism
   */
  storedAsAssets?: boolean | null;
  /**
   * Get an estimate in minutes on how long the work is expected to take
   */
  eta?: number | null;
};

/**
 * A workflow step for training image resources.
 */
export type ImageResourceTrainingStep = WorkflowStep & {
  input: ImageResourceTrainingInput;
  output?: ImageResourceTrainingOutput;
} & {
  $type: 'imageResourceTraining';
};

export type ImageResourceTrainingStepTemplate = WorkflowStepTemplate & {
  input: ImageResourceTrainingInput;
} & {
  $type: 'imageResourceTraining';
};

export type ImageTransformJob = Job & {
  /**
   * The url of the image to transform
   */
  imageUrl?: string;
  transformer?: ImageTransformer;
  /**
   * Get the key of the destination blob to upload the result to
   */
  destinationBlobKey?: string;
  /**
   * A untyped set of parameters that are associated with this job
   */
  params?: {
    [key: string]: unknown;
  };
  /**
   * Get or set the URL where the transformed image will be uploaded to
   */
  destinationUrl?: string | null;
  readonly type?: string;
} & {
  $type: 'imageTransform';
};

export type $type11 = 'imageTransform';

export const $type11 = {
  IMAGE_TRANSFORM: 'imageTransform',
} as const;

/**
 * Available image transformers.
 */
export type ImageTransformer = 'canny' | 'depthZoe' | 'softedgePidinet' | 'rembg';

/**
 * Available image transformers.
 */
export const ImageTransformer = {
  CANNY: 'canny',
  DEPTH_ZOE: 'depthZoe',
  SOFTEDGE_PIDINET: 'softedgePidinet',
  REMBG: 'rembg',
} as const;

export type Job = {
  $type: string;
  /**
   * A unique id for this job
   */
  id?: string;
  /**
   * The date when this job got created
   */
  createdAt?: string;
  /**
   * The date for when this job was set to expire
   */
  expireAt?: string | null;
  /**
   * A webhook to be invoked when the job receives a status update
   */
  webhook?: string | null;
  /**
   * A set of user defined properties that can be used to index and partition this job
   */
  properties?: {
    [key: string]: unknown;
  };
  /**
   * The type of this job as a string
   */
  type?: string;
  /**
   * Get a cost for this job
   */
  cost?: number;
  /**
   * The max number of retries before we give up
   */
  maxRetryAttempt?: number;
  /**
   * Get or set a list of dependencies that this job has
   */
  dependencies?: {
    [key: string]: Array<DynamicAssignment>;
  };
  /**
   * Get or set the name of the consumer that issued this job
   */
  issuedBy?: string | null;
  /**
   * Get or set the version of this job, this is used to track changes to the job schema
   */
  version?: number;
  /**
   * Get or set a list of dependencies that this job has
   */
  jobDependencies?: Array<JobDependency>;
  /**
   * The total duration that the job can be claimed
   */
  claimDuration?: string;
  /**
   * Get a list of resources that this job depends on
   */
  resources?: Array<string>;
  /**
   * An internal property to mark that the job has been recovered. We use this to not fiddle with up/down counters as we may have missed other counters
   */
  recovered?: boolean;
};

export type JobDependency = {
  jobId?: string;
  onFailure?: JobDependencyContinuation;
  onSuccess?: JobDependencyContinuation;
  dynamicAssignments?: Array<DynamicAssignment>;
};

export type JobDependencyContinuation = 'fail' | 'skip' | 'continue';

export const JobDependencyContinuation = {
  FAIL: 'fail',
  SKIP: 'skip',
  CONTINUE: 'continue',
} as const;

/**
 * Available levels of job support.
 */
export type JobSupport = 'unsupported' | 'unavailable' | 'available';

/**
 * Available levels of job support.
 */
export const JobSupport = {
  UNSUPPORTED: 'unsupported',
  UNAVAILABLE: 'unavailable',
  AVAILABLE: 'available',
} as const;

/**
 * Array of operations to perform
 */
export type JsonPatchDocument = Array<JsonPatchOperation>;

/**
 * Describes a single operation in a JSON Patch document. Includes the operation type, the target property path, and the value to be used.
 */
export type JsonPatchOperation = {
  /**
   * The operation type. Allowed values: 'add', 'remove', 'replace', 'move', 'copy', 'test'.
   */
  op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
  /**
   * The JSON Pointer path to the property in the target document where the operation is to be applied.
   */
  path: string;
  /**
   * Should be a path, required when using move, copy
   */
  from?: string;
  /**
   * The value to apply for 'add', 'replace', or 'test' operations. Not required for 'remove', 'move', or 'copy'.
   */
  value?:
    | string
    | number
    | boolean
    | {
        [key: string]: unknown;
      }
    | unknown[]
    | null;
};

/**
 * The operation type. Allowed values: 'add', 'remove', 'replace', 'move', 'copy', 'test'.
 */
export type op = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';

/**
 * The operation type. Allowed values: 'add', 'remove', 'replace', 'move', 'copy', 'test'.
 */
export const op = {
  ADD: 'add',
  REMOVE: 'remove',
  REPLACE: 'replace',
  MOVE: 'move',
  COPY: 'copy',
  TEST: 'test',
} as const;

export type KlingCameraControl = {
  config?: KlingCameraControlConfig;
};

export type KlingCameraControlConfig = {
  /**
   * Horizontal, controls the camera's movement along the horizontal axis (translation along the x-axis).
   */
  horizontal?: number | null;
  /**
   * Vertical, controls the camera's movement along the vertical axis (translation along the y-axis).
   */
  vertical?: number | null;
  /**
   * Pan, controls the camera's rotation in the horizontal plane (rotation around the y-axis).
   */
  pan?: number | null;
  /**
   * Tilt, controls the camera's rotation in the horizontal plane (rotation around the y-axis).
   */
  tilt?: number | null;
  /**
   * Roll, controls the camera's rolling amount (rotation around the z-axis).
   */
  roll?: number | null;
  /**
   * Zoom, controls the change in the camera's focal length, affecting the proximity of the field of view.
   */
  zoom?: number | null;
};

export type KlingMode = 'standard' | 'professional';

export const KlingMode = {
  STANDARD: 'standard',
  PROFESSIONAL: 'professional',
} as const;

export type KlingModel = 'v1' | 'v1_5';

export const KlingModel = {
  V1: 'v1',
  V1_5: 'v1_5',
} as const;

export type KlingVideoGenAspectRatio = '16:9' | '9:16' | '1:1';

export const KlingVideoGenAspectRatio = {
  _16_9: '16:9',
  _9_16: '9:16',
  _1_1: '1:1',
} as const;

export type KlingVideoGenDuration = '5' | '10';

export const KlingVideoGenDuration = {
  _5: '5',
  _10: '10',
} as const;

export type KlingVideoGenInput = VideoGenInput & {
  model?: KlingModel;
  negativePrompt?: string | null;
  cfgScale?: number;
  mode?: KlingMode;
  aspectRatio?: KlingVideoGenAspectRatio;
  duration?: KlingVideoGenDuration;
  cameraControl?: KlingCameraControl;
  sourceImageUrl?: string | null;
  sourceImage?: SourceImage;
} & {
  engine: 'kling';
};

export type engine4 = 'kling';

export const engine4 = {
  KLING: 'kling',
} as const;

export type KohyaImageResourceTrainingInput = ImageResourceTrainingInput & {
  /**
   * An epoch is one set of learning. By default, we will save a maximum of 20 epochs (evenly distributed), and they are all available for download.
   */
  maxTrainEpochs?: number;
  /**
   * Num Repeats defines how many times each individual image gets put into VRAM. As opposed to batch size, which is how many images are placed into VRAM at once.
   */
  numRepeats?: number;
  /**
   * Batch size is the number of images that will be placed into VRAM at once. A batch size of 2 will train two images at a time, simultaneously.
   */
  trainBatchSize?: number | null;
  /**
   * Specify the maximum resolution of training images. If the training images exceed the resolution specified here, they will be scaled down to this resolution
   */
  resolution?: number | null;
  /**
   * Sorts images into buckets by size for the purposes of training. If your training images are all the same size, you can turn this option off, but leaving it on has no effect.
   */
  enableBucket?: boolean;
  /**
   * Randomly changes the order of your tags during training. The intent of shuffling is to improve learning. If you are using captions (sentences), this option has no meaning.
   */
  shuffleCaption?: boolean;
  /**
   * If your training images have tags, you can randomly shuffle them.
   * However, if you have words that you want to keep at the beginning, you can use this option to specify "Keep the first 0 words at the beginning".
   * This option does nothing if the Shuffle Tags option is off.
   */
  keepTokens?: number;
  /**
   * Determines which layer's vector output will be used. There are 12 layers, and setting the skip will select "xth from the end" of the total layers. For anime, we use 2. For everything else, 1.
   */
  clipSkip?: number;
  /**
   * If this option is turned on, the image will be horizontally flipped randomly. It can learn left and right angles, which is useful when you want to learn symmetrical people and objects.
   */
  flipAugmentation?: boolean;
  /**
   * Sets the learning rate for U-Net. This is the learning rate when performing additional learning on each attention block (and other blocks depending on the setting) in U-Net
   */
  unetLR?: number;
  /**
   * Sets the learning rate for the text encoder. The effect of additional training on text encoders affects the entire U-Net.
   */
  textEncoderLR?: number;
  /**
   * You can change the learning rate in the middle of learning. A scheduler is a setting for how to change the learning rate.
   */
  lrScheduler?: 'constant' | 'cosine' | 'cosine_with_restarts' | 'linear' | null;
  /**
   * This option specifies how many cycles the scheduler runs during training. It is only used when "cosine_with_restarts" or "polynomial" is used as the scheduler.
   */
  lrSchedulerNumCycles?: number;
  /**
   * Learning is performed by putting noise of various strengths on the training image,
   * but depending on the difference in strength of the noise on which it is placed, learning will be
   * stable by moving closer to or farther from the learning target.
   *
   * Min SNR gamma was introduced to compensate for that. When learning images have little noise,
   * it may deviate greatly from the target, so try to suppress this jump.
   */
  minSnrGamma?: number | null;
  /**
   * The larger the Dim setting, the more learning information can be stored, but the possibility of learning unnecessary information other than the learning target increases. A larger Dim also increases LoRA file size.
   */
  networkDim?: number | null;
  /**
   * The smaller the Network alpha value, the larger the stored LoRA neural net weights.
   * For example, with an Alpha of 16 and a Dim of 32, the strength of the weight used is 16/32 = 0.5,
   * meaning that the learning rate is only half as powerful as the Learning Rate setting.
   *
   * If Alpha and Dim are the same number, the strength used will be 1 and will have no effect on the learning rate.
   */
  networkAlpha?: number | null;
  /**
   * Adds noise to training images. 0 adds no noise at all. A value of 1 adds strong noise.
   */
  noiseOffset?: number | null;
  /**
   * The optimizer determines how to update the neural net weights during training.
   * Various methods have been proposed for smart learning, but the most commonly used in LoRA learning
   * is "AdamW8bit" or "Adafactor" for SDXL.
   */
  optimizerType?: string | null;
  readonly targetSteps?: number | null;
} & {
  engine: 'kohya';
};

/**
 * You can change the learning rate in the middle of learning. A scheduler is a setting for how to change the learning rate.
 */
export type lrScheduler = 'constant' | 'cosine' | 'cosine_with_restarts' | 'linear';

/**
 * You can change the learning rate in the middle of learning. A scheduler is a setting for how to change the learning rate.
 */
export const lrScheduler = {
  CONSTANT: 'constant',
  COSINE: 'cosine',
  COSINE_WITH_RESTARTS: 'cosine_with_restarts',
  LINEAR: 'linear',
} as const;

export type engine5 = 'kohya';

export const engine5 = {
  KOHYA: 'kohya',
} as const;

/**
 * LLM prompt augmentaition capabilities.
 */
export type LLMPromptAugmentationCapabilities = {
  [key: string]: unknown;
};

export type LLMPromptAugmentationJob = Job & {
  /**
   * The primary model to use.
   */
  model: string;
  /**
   * The base prompt.
   */
  basePrompt?: string | null;
  /**
   * A list of prompts.
   */
  prompts?: Array<string>;
  /**
   * The temp.
   */
  temp?: number;
  /**
   * The type.
   */
  readonly type?: string;
} & {
  $type: 'llmPromptAugmentation';
};

export type $type12 = 'llmPromptAugmentation';

export const $type12 = {
  LLM_PROMPT_AUGMENTATION: 'llmPromptAugmentation',
} as const;

export type LightricksAspectRatio = 'square' | 'landscape' | 'portrait';

export const LightricksAspectRatio = {
  SQUARE: 'square',
  LANDSCAPE: 'landscape',
  PORTRAIT: 'portrait',
} as const;

export type LightricksVideoGenInput = VideoGenInput & {
  negativePrompt?: string | null;
  cfgScale?: number;
  aspectRatio?: LightricksAspectRatio;
  frameRate?: number;
  duration?: number;
  seed?: number | null;
  steps?: number;
  resolution?: ValueTupleOfInt32AndInt32;
} & {
  engine: 'lightricks';
};

export type engine6 = 'lightricks';

export const engine6 = {
  LIGHTRICKS: 'lightricks',
} as const;

export type MediaCaptioningJob = Job & {
  model: string;
  modelId?: number;
  mediaUrl: string;
  temperature?: number;
  maxNewTokens?: number;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'mediaCaptioning';
};

export type $type13 = 'mediaCaptioning';

export const $type13 = {
  MEDIA_CAPTIONING: 'mediaCaptioning',
} as const;

export type MediaTaggingJob = Job & {
  modelId?: number;
  mediaUrl?: string;
  readonly type?: string;
} & {
  $type: 'mediaTagging';
};

export type $type14 = 'mediaTagging';

export const $type14 = {
  MEDIA_TAGGING: 'mediaTagging',
} as const;

export type MemoryOfByte = {
  length?: number;
  isEmpty?: boolean;
  span?: SpanOfByte;
};

export type MiniMaxVideoGenInput = VideoGenInput & {
  model?: MiniMaxVideoGenModel;
  enablePromptEnhancer?: boolean;
  sourceImage?: SourceImage;
} & {
  engine: 'minimax';
};

export type engine7 = 'minimax';

export const engine7 = {
  MINIMAX: 'minimax',
} as const;

export type MiniMaxVideoGenModel = 'hailou';

export const MiniMaxVideoGenModel = {
  HAILOU: 'hailou',
} as const;

export type MochiVideoGenInput = VideoGenInput & {
  seed?: number;
  enablePromptEnhancer?: boolean;
} & {
  engine: 'mochi';
};

export type engine8 = 'mochi';

export const engine8 = {
  MOCHI: 'mochi',
} as const;

export type MochiVideoGenJob = Job & {
  prompt: string;
  seed?: number;
  mediaHash: string;
  destinationUrl: string;
  enablePromptEnhancer?: boolean;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'mochi';
};

export type $type15 = 'mochi';

export const $type15 = {
  MOCHI: 'mochi',
} as const;

export type MovieRatingJob = Job & {
  mediaUrl?: string;
  model?: string | null;
  blobKey?: string | null;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'movieRating';
};

export type $type16 = 'movieRating';

export const $type16 = {
  MOVIE_RATING: 'movieRating',
} as const;

export type NSFWLevel = 'pg' | 'pG13' | 'r' | 'x' | 'xxx' | 'na';

export const NSFWLevel = {
  PG: 'pg',
  P_G13: 'pG13',
  R: 'r',
  X: 'x',
  XXX: 'xxx',
  NA: 'na',
} as const;

/**
 * Available options for priority.
 */
export type Priority = 'high' | 'normal' | 'low';

/**
 * Available options for priority.
 */
export const Priority = {
  HIGH: 'high',
  NORMAL: 'normal',
  LOW: 'low',
} as const;

export type ProblemDetails = {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  '[key: string]': (unknown | string | number) | undefined;
};

/**
 * Details of processing statistics.
 */
export type ProcessingStatistics = {
  /**
   * The total number of jobs requested.
   */
  totalJobsRequested?: number;
  /**
   * The total cost of jobs requested.
   */
  totalCostRequested?: number;
  /**
   * The total number of successful jobs.
   */
  totalJobsSucceeded?: number;
  /**
   * The total cost of successful jobs.
   */
  totalCostSucceeded?: number;
  /**
   * The total number of rejected jobs.
   */
  totalJobsRejected?: number;
  /**
   * The total cost of rejected jobs.
   */
  totalCostRejected?: number;
  /**
   * The total number of late rejected jobs.
   */
  totalJobsLateRejected?: number;
  /**
   * The total cost of laterejected jobs.
   */
  totalCostLateRejected?: number;
  /**
   * The total number of expired jobs.
   */
  totalJobsExpired?: number;
  /**
   * The total cost of expired jobs.
   */
  totalCostExpired?: number;
  /**
   * The total number of failed jobs.
   */
  totalJobsFailed?: number;
  /**
   * The total cost of failed jobs.
   */
  totalCostFailed?: number;
  /**
   * The total number of completed jobs.
   */
  totalJobsCompleted?: number;
  /**
   * The total cost of completed jobs.
   */
  totalCostCompleted?: number;
};

/**
 * Details for a specific resource.
 */
export type ResourceInfo = {
  /**
   * An AIR ID for the resource.
   */
  air: string;
  /**
   * The resource size in bytes.
   */
  size: number;
  /**
   * A collection of hashes.
   */
  hashes: {
    [key: string]: string;
  };
  /**
   * An array of download urls.
   */
  downloadUrls: Array<string>;
  /**
   * The name of the resource.
   */
  resourceName?: string | null;
  /**
   * The name of the version.
   */
  versionName?: string | null;
  /**
   * The date time to invalidate at.
   */
  invalidateAt?: string | null;
  /**
   * A DateTime representing when early access for the resource ends.
   */
  earlyAccessEndsAt?: string | null;
  /**
   * A bool indicating if permission is required to use this resource.
   */
  checkPermission?: boolean;
  /**
   * A bool indicating if generation is enabled for this resource.
   */
  canGenerate?: boolean;
  /**
   * An optional limit on the number of uses for this resource per user that has early acccess.
   */
  freeTrialLimit?: number | null;
  /**
   * Wether this resource requires authorization.
   */
  requiresAuthorization?: boolean | null;
  fileFormat?: FileFormat;
};

/**
 * The available options for schedulers used in image generation.
 */
export type Scheduler =
  | 'eulerA'
  | 'euler'
  | 'lms'
  | 'heun'
  | 'dpM2'
  | 'dpM2A'
  | 'dpM2SA'
  | 'dpM2M'
  | 'dpmsde'
  | 'dpmFast'
  | 'dpmAdaptive'
  | 'lmsKarras'
  | 'dpM2Karras'
  | 'dpM2AKarras'
  | 'dpM2SAKarras'
  | 'dpM2MKarras'
  | 'dpmsdeKarras'
  | 'ddim'
  | 'plms'
  | 'uniPC'
  | 'undefined'
  | 'lcm'
  | 'ddpm'
  | 'deis'
  | 'dpM3MSDE';

/**
 * The available options for schedulers used in image generation.
 */
export const Scheduler = {
  EULER_A: 'eulerA',
  EULER: 'euler',
  LMS: 'lms',
  HEUN: 'heun',
  DP_M2: 'dpM2',
  DP_M2A: 'dpM2A',
  DP_M2SA: 'dpM2SA',
  DP_M2M: 'dpM2M',
  DPMSDE: 'dpmsde',
  DPM_FAST: 'dpmFast',
  DPM_ADAPTIVE: 'dpmAdaptive',
  LMS_KARRAS: 'lmsKarras',
  DP_M2KARRAS: 'dpM2Karras',
  DP_M2AKARRAS: 'dpM2AKarras',
  DP_M2SAKARRAS: 'dpM2SAKarras',
  DP_M2MKARRAS: 'dpM2MKarras',
  DPMSDE_KARRAS: 'dpmsdeKarras',
  DDIM: 'ddim',
  PLMS: 'plms',
  UNI_PC: 'uniPC',
  UNDEFINED: 'undefined',
  LCM: 'lcm',
  DDPM: 'ddpm',
  DEIS: 'deis',
  DP_M3MSDE: 'dpM3MSDE',
} as const;

/**
 * Details for a similarity search job.
 */
export type SimilaritySearchJob = Job & {
  /**
   * An AIR ID representing the primary model.
   */
  model: string;
  /**
   * A value for the NSFW filter.
   */
  nsfwFilter: string;
  /**
   * The prompt provided.
   */
  prompt: string;
  /**
   * A collection of parameters.
   */
  params: {
    [key: string]: unknown;
  };
  /**
   * The job type.
   */
  readonly type?: string;
} & {
  $type: 'similaritySearch';
};

export type $type17 = 'similaritySearch';

export const $type17 = {
  SIMILARITY_SEARCH: 'similaritySearch',
} as const;

export type SourceImage = {
  buffer?: MemoryOfByte;
};

export type SpanOfByte = {
  length?: number;
  isEmpty?: boolean;
};

/**
 * A subscription for pushed based notifications.
 */
export type Subscription = {
  /**
   * The webhook url.
   */
  webhook: string;
};

/**
 * Input for an text to image step.
 */
export type TextToImageInput = {
  /**
   * The number of batches to run.
   */
  quantity?: number;
  /**
   * The size of each batch.D
   */
  batchSize?: number;
  /**
   * The AIR of the checkpoint model to use for generation.
   */
  model: string;
  /**
   * Get or set a associative list of additional networks. Use the AIR of the network as the key.
   */
  additionalNetworks?: {
    [key: string]: ImageJobNetworkParams;
  };
  /**
   * Get or set a associative list of ControlNets.
   */
  controlNets?: Array<ImageJobControlNet>;
  /**
   * The provided text prompt.
   */
  prompt: string;
  /**
   * The provided negative text prompt.
   */
  negativePrompt?: string | null;
  scheduler?: Scheduler;
  /**
   * The number of steps for image generation.
   */
  steps?: number;
  /**
   * The CFG scale value for image generation.
   */
  cfgScale?: number;
  /**
   * The desired image width in pixels.
   */
  width: number;
  /**
   * The desired image height in pixels.
   */
  height: number;
  /**
   * The seed to use in image generation. Defaults to a random value if left unpopulated.
   */
  seed?: number;
  /**
   * The clip skip value for image generation.
   */
  clipSkip?: number;
  /**
   * External metadata that will be stored with the image
   */
  imageMetadata?: string | null;
  /**
   * An optional engine to use for generation.
   */
  engine?: string | null;
};

/**
 * A text to image generation job.
 */
export type TextToImageJob = Job & {
  /**
   * An AIR representing the model to use.
   */
  model: string;
  params: ImageJobParams;
  /**
   * The hash for the output image.
   */
  imageHash: string;
  /**
   * Get or set a associative list of additional networks. Each network is identified by a hash code.
   */
  additionalNetworks?: {
    [key: string]: ImageJobNetworkParams;
  };
  /**
   * Get or set the URL where the image will be uploaded to.
   */
  destinationUrl?: string | null;
  /**
   * A value indicating whether to store the image as a blob or as a legacy image.
   */
  storeAsBlob?: boolean;
  /**
   * Get or set a list of control nets that should be applied with this textToImage job.
   */
  controlNets?: Array<ImageJobControlNet>;
  /**
   * The duration for which this job can be claimed for.
   */
  readonly claimDuration?: string;
  /**
   * The job type.
   */
  readonly type?: string;
} & {
  $type: 'textToImage';
};

export type $type18 = 'textToImage';

export const $type18 = {
  TEXT_TO_IMAGE: 'textToImage',
} as const;

/**
 * Represents the output of a TextToImage workflow step.
 */
export type TextToImageOutput = {
  /**
   * A collection of output images.
   */
  images: Array<Blob>;
};

/**
 * A workflow step for text to image generations.
 */
export type TextToImageStep = WorkflowStep & {
  input: TextToImageInput;
  output?: TextToImageOutput;
} & {
  $type: 'textToImage';
};

export type TextToImageStepTemplate = WorkflowStepTemplate & {
  input: TextToImageInput;
} & {
  $type: 'textToImage';
};

/**
 * Transaction information.
 */
export type TransactionInfo = {
  type: TransactionType;
  /**
   * The transaction amount.
   */
  amount: number;
  /**
   * The transaction ID.
   */
  id?: string | null;
  accountType?: BuzzClientAccount;
};

export type TransactionSummary = {
  /**
   * Get a list of individual transactions.
   */
  list?: Array<TransactionInfo>;
};

export type TransactionType = 'debit' | 'credit';

export const TransactionType = {
  DEBIT: 'debit',
  CREDIT: 'credit',
} as const;

export type TranscodeInput = {
  sourceUrl: string;
  containerFormat?: ContainerFormat;
  width?: number;
  destinationUrl?: string | null;
};

export type TranscodeOutput = {
  /**
   * Gets the id of the blob that contains the media.
   */
  id: string;
  /**
   * Gets a value indicating whether the media is available.
   */
  available: boolean;
  /**
   * Gets a url that can be used to preview the media.
   */
  url?: string | null;
  /**
   * Get when the url is set to expire
   */
  urlExpiresAt?: string | null;
  /**
   * Get the id of the job that is associated with this media.
   */
  jobId: string;
};

export type TranscodeStep = WorkflowStep & {
  input: TranscodeInput;
  output?: TranscodeOutput;
} & {
  $type: 'transcode';
};

export type $type19 = 'transcode';

export const $type19 = {
  TRANSCODE: 'transcode',
} as const;

export type TranscodeStepTemplate = WorkflowStepTemplate & {
  input: TranscodeInput;
} & {
  $type: 'transcode';
};

export type TryOnUInput = {
  subjectUrl: string;
  garmentUrl: string;
  subjectMaskUrl?: string;
  subjectMaskBlobKey?: string;
  garmentDescription?: string;
  maskSubject?: boolean;
  cropSubject?: boolean;
  steps?: number;
  seed?: number;
};

export type TryOnUJob = Job & {
  subjectUrl: string;
  garmentUrl: string;
  subjectMaskUrl: string;
  garmentDescription?: string | null;
  maskSubject?: boolean;
  cropSubject?: boolean;
  steps?: number;
  seed?: number;
  destinationBlobKey: string;
  readonly type?: string;
  readonly claimDuration?: string;
} & {
  $type: 'tryOnU';
};

export type $type20 = 'tryOnU';

export const $type20 = {
  TRY_ON_U: 'tryOnU',
} as const;

export type TryOnUOutput = {
  blob: Blob;
};

export type TryOnUStep = WorkflowStep & {
  input: TryOnUInput;
  output?: TryOnUOutput;
} & {
  $type: 'tryOnU';
};

export type TryOnUStepTemplate = WorkflowStepTemplate & {
  input: TryOnUInput;
} & {
  $type: 'tryOnU';
};

/**
 * An request for updating a workflow.
 */
export type UpdateWorkflowRequest = {
  status?: UpdateWorkflowStatus;
  /**
   * An optional set of new properties to set on the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * An optional set of new tags to set on the workflow.
   */
  tags?: Array<string> | null;
};

/**
 * Available statuses for updating workflows.
 */
export type UpdateWorkflowStatus = 'canceled';

/**
 * Available statuses for updating workflows.
 */
export const UpdateWorkflowStatus = {
  CANCELED: 'canceled',
} as const;

export type UpdateWorkflowStepRequest = {
  /**
   * An set of new properties to set on the workflow step.
   */
  metadata: {
    [key: string]: unknown;
  };
};

export type ValidationProblemDetails = {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  errors?: {
    [key: string]: Array<string>;
  };
  '[key: string]': (unknown | string | number) | undefined;
};

export type ValueTupleOfInt32AndInt32 = {
  [key: string]: unknown;
};

export type ValueTupleOfStringAndInt32 = {
  [key: string]: unknown;
};

export type VideoBlob = Blob & {
  width?: number | null;
  height?: number | null;
} & {
  type: 'video';
};

export type type = 'video';

export const type = {
  VIDEO: 'video',
} as const;

export type VideoGenInput = {
  engine: string;
  prompt: string;
};

export type VideoGenOutput = {
  video?: Blob;
};

export type VideoGenStep = WorkflowStep & {
  input: VideoGenInput;
  output?: VideoGenOutput;
} & {
  $type: 'videoGen';
};

export type $type21 = 'videoGen';

export const $type21 = {
  VIDEO_GEN: 'videoGen',
} as const;

export type VideoGenStepTemplate = WorkflowStepTemplate & {
  input: VideoGenInput;
} & {
  $type: 'videoGen';
};

export type WDTaggingJob = Job & {
  model?: string;
  mediaUrl?: string;
  threshold?: number | null;
  movieRatingModel?: string | null;
  prompt?: string | null;
  readonly claimDuration?: string;
  readonly type?: string;
} & {
  $type: 'wdTagging';
};

export type $type22 = 'wdTagging';

export const $type22 = {
  WD_TAGGING: 'wdTagging',
} as const;

/**
 * Details of a worker's capabilities.
 */
export type WorkerCapabilities = {
  image?: WorkerImageCapabilities;
  media?: WorkerMediaCapabilities;
  modelManagement?: WorkerModelPreparationCapabilities;
  configurationManagement?: WorkerConfigurationCapabilities;
  similaritySearch?: WorkerSimilaritySearchCapabilities;
  llmPromptAugmentation?: LLMPromptAugmentationCapabilities;
  humanoidImageMask?: WorkerHumanoidImageMaskCapabilities;
  tryOnU?: WorkerTryOnUCapabilities;
  haiper?: WorkerHaiperCapabilities;
  kling?: WorkerKlingCapabilities;
  miniMax?: WorkerMiniMaxCapabilities;
};

/**
 * Details of a worker's configuration capabilities.
 */
export type WorkerConfigurationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details for a particular worker.
 */
export type WorkerDetails = {
  /**
   * The worker's ID.
   */
  id: string;
  /**
   * The worker's name.
   */
  name: string;
  /**
   * The worker's active job count.
   */
  activeJobs?: number;
  /**
   * The number of jobs in the worker's queue.
   */
  queueSize?: number;
  /**
   * The total cost of job's in the worker's queue.
   */
  queueDepth?: number;
  /**
   * The worker's start date / time.
   */
  startDate?: string;
  /**
   * The worker's last request date / time.
   */
  lastRequestDate?: string | null;
  /**
   * The worker's expiration date / time.
   */
  expirationDate?: string | null;
  statistics?: ProcessingStatistics;
  /**
   * The worker's succeeded job throughput rate.
   */
  succeededThroughputRate?: number;
  /**
   * The worker's failed job throughput rate.
   */
  failedThroughputRate?: number;
  /**
   * The worker's idle rate.
   */
  idleRate?: number;
  /**
   * The date / time of the worker's last successfully completed job.
   */
  lastSuccesfullyCompletedJobDate?: string | null;
  /**
   * The date / time of the worker's last job update.
   */
  lastJobUpdateDate?: string | null;
  /**
   * The date / time that the worker's subscription was set.
   */
  subscriptionSetDate?: string | null;
  /**
   * The date / time that the worker was quarantined.
   */
  quarantineDate?: string | null;
  /**
   * The rate at which this worker has been downloading
   */
  resourceDownloadRate?: number;
  /**
   * The rate at which this worker has been evicting resources
   */
  resourceEvictionRate?: number;
  /**
   * The size in bytes of resources that are queued up for this worker to download
   */
  upcomingResourcesSize?: number | null;
};

export type WorkerHaiperCapabilities = {
  [key: string]: unknown;
};

export type WorkerHumanoidImageMaskCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's image capabilities.
 */
export type WorkerImageCapabilities = {
  textToImage?: WorkerImageTextToImageCapabilities;
  imageToImage?: WorkerImageImageToImageCapabilities;
  transform?: WorkerImageTransformCapabilities;
  resourceTraining?: WorkerImageResourceTrainingCapabilities;
  embedding?: WorkerImageEmbeddingCapabilities;
};

/**
 * Details of a worker's image embedding capabilities.
 */
export type WorkerImageEmbeddingCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's image to image capabilities.
 */
export type WorkerImageImageToImageCapabilities = {
  /**
   * The worker's maximum supported image size for image to image (squared).
   */
  size?: number;
  /**
   * A list of schedulers the worker supports for image to image.
   */
  schedulers?: Array<Scheduler>;
  /**
   * The number of ControlNets the worker supports for image to image (at once).
   */
  controlNet?: number;
  /**
   * Indicates whether the worker supports inpaiting.
   */
  inpainting?: boolean;
};

/**
 * Details of a worker's image resource training capabilities.
 */
export type WorkerImageResourceTrainingCapabilities = {
  engines?: Array<string>;
};

/**
 * Details of a worker's text to image capabilities.
 */
export type WorkerImageTextToImageCapabilities = {
  /**
   * The worker's maximum supported image size for text to image (squared).
   */
  size?: number;
  /**
   * A list of schedulers the worker supports for text to image.
   */
  schedulers?: Array<Scheduler>;
  /**
   * The number of ControlNets the worker supports for text to image (at once).
   */
  controlNet?: number;
  /**
   * A list of engines that this worker supports for text to image.
   */
  engines?: Array<string> | null;
};

/**
 * Details of a worker's image transform capabilities.
 */
export type WorkerImageTransformCapabilities = {
  /**
   * A list of supported image transformers.
   */
  transformers?: Array<ImageTransformer>;
};

export type WorkerKlingCapabilities = {
  [key: string]: unknown;
};

export type WorkerMediaAgeClassificationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media capabilities.
 */
export type WorkerMediaCapabilities = {
  wdTagging?: WorkerMediaWDTaggingCapabilities;
  comfy?: WorkerMediaComfyCapabilities;
  tagging?: WorkerMediaTaggingCapabilities;
  movieRating?: WorkerMediaMovieRatingCapabilities;
  transcode?: WorkerMediaTranscodeCapabilities;
  captioning?: WorkerMediaCaptioningCapabilities;
  ageClassification?: WorkerMediaAgeClassificationCapabilities;
  ocrSafetyClassification?: WorkerMediaOCRSafetyClassificationCapabilities;
};

export type WorkerMediaCaptioningCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media comfy capabilities.
 */
export type WorkerMediaComfyCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media movie rating capabilities.
 */
export type WorkerMediaMovieRatingCapabilities = {
  [key: string]: unknown;
};

export type WorkerMediaOCRSafetyClassificationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media tagging capabilities.
 */
export type WorkerMediaTaggingCapabilities = {
  [key: string]: unknown;
};

export type WorkerMediaTranscodeCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's media WD tagging capabilities.
 */
export type WorkerMediaWDTaggingCapabilities = {
  [key: string]: unknown;
};

export type WorkerMiniMaxCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's model preparation capabilities.
 */
export type WorkerModelPreparationCapabilities = {
  [key: string]: unknown;
};

/**
 * Details of a worker's registration.
 */
export type WorkerRegistration = {
  /**
   * The worker's name.
   */
  name: string;
  /**
   * A hash set of resource types the worker can retrieve on demand.
   */
  onDemandResourceTypes?: Array<string>;
  capabilities?: WorkerCapabilities;
  subscription?: Subscription;
  type?: WorkerType;
  /**
   * The number of requests the worker can handle at once.
   */
  concurrentLimit?: number;
  /**
   * A collection of ecosystems the worker supports.
   */
  ecosystems?: {
    [key: string]: EcosystemElement;
  };
  /**
   * A collection of information about the availability of particular resources on this worker.
   */
  resources?: {
    [key: string]: WorkerResourceStatus;
  };
  /**
   * The name of the closest cache level that this worker can interact with.
   */
  cacheLevel?: string | null;
  /**
   * The max queue size before the worker stops accepting requests that require cold swapping.
   */
  maxColdSwapQueueSize?: number | null;
  /**
   * The max size in Mb of downloads that can be pending.
   */
  maxPendingResourceSize?: number | null;
  /**
   * A value indicating if worker should consume jobs that are not yet available.
   */
  consumeUnavailableJobs?: boolean;
  /**
   * An optional identifier unique to this worker.
   */
  nodeIdentifier?: string | null;
  /**
   * An optional boost to the scoring of this worker. This can be used to make a worker more or less likely to be selected for work
   */
  scoreBoost?: number | null;
  /**
   * A list of file formats that the worker supports. If none are specified then all formats are considered supported
   */
  supportedFileFormats?: Array<FileFormat> | null;
  preferredDownloadSource?: DownloadSource;
  /**
   * A collection of labels that will be applied to metrics produced by these workers
   */
  labels?: {
    [key: string]: string;
  } | null;
};

/**
 * Options for representing the status for a resource on a worker.
 */
export type WorkerResourceAvailability =
  | 'unknown'
  | 'unsupported'
  | 'unavailable'
  | 'available'
  | 'providerUnsupported';

/**
 * Options for representing the status for a resource on a worker.
 */
export const WorkerResourceAvailability = {
  UNKNOWN: 'unknown',
  UNSUPPORTED: 'unsupported',
  UNAVAILABLE: 'unavailable',
  AVAILABLE: 'available',
  PROVIDER_UNSUPPORTED: 'providerUnsupported',
} as const;

/**
 * Details for the status of a resource on a particular worker.
 */
export type WorkerResourceStatus = {
  availability: WorkerResourceAvailability;
  /**
   * The cost associated with this resource.
   */
  cost?: number;
};

/**
 * Details of a worker's similarity search capabilities.
 */
export type WorkerSimilaritySearchCapabilities = {
  [key: string]: unknown;
};

export type WorkerTryOnUCapabilities = {
  [key: string]: unknown;
};

/**
 * Available values for worker type.
 */
export type WorkerType = 'normal' | 'deferred' | 'test';

/**
 * Available values for worker type.
 */
export const WorkerType = {
  NORMAL: 'normal',
  DEFERRED: 'deferred',
  TEST: 'test',
} as const;

/**
 * Details of a workflow.
 */
export type Workflow = {
  /**
   * The ID for the workflow.
   */
  id?: string | null;
  /**
   * The date / time the workflow was created.
   */
  createdAt?: string;
  transactions?: TransactionSummary;
  /**
   * A collection of user defined metadata for the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  };
  status?: WorkflowStatus;
  /**
   * The date / time the workflow was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the workflow was completed. Null if not yet complete.
   */
  completedAt?: string | null;
  /**
   * An optional list of tags for the workflow.
   */
  tags?: Array<string>;
  /**
   * Get an associated collection of arguments
   */
  arguments?: {
    [key: string]: unknown;
  };
  /**
   * The steps for the workflow.
   */
  steps?: Array<WorkflowStep>;
  /**
   * An array of callback details for the workflow.
   */
  callbacks?: Array<WorkflowCallback>;
  tips?: WorkflowTips;
  cost?: WorkflowCost;
  nsfwLevel?: NSFWLevel;
  /**
   * Get or set whether this workflow is experimental
   */
  experimental?: boolean | null;
};

/**
 * Details of a callback setup for a workflow.
 */
export type WorkflowCallback = {
  /**
   * The url for the callback.
   */
  url: string;
  /**
   * An array of event types to send to the callback.
   */
  type: Array<
    | 'workflow:*'
    | 'workflow:unassigned'
    | 'workflow:processing'
    | 'workflow:succeeded'
    | 'workflow:failed'
    | 'workflow:expired'
    | 'workflow:canceled'
    | 'step:*'
    | 'step:unassigned'
    | 'step:processing'
    | 'step:succeeded'
    | 'step:failed'
    | 'step:expired'
    | 'step:canceled'
    | 'job:*'
    | 'job:unassigned'
    | 'job:processing'
    | 'job:succeeded'
    | 'job:failed'
    | 'job:expired'
    | 'job:canceled'
  >;
};

export type WorkflowCost = {
  /**
   * The base cost of this request, excludsing any tips
   */
  base?: number;
  /**
   * A breakdown of the cost factors for this request
   */
  factors?: {
    [key: string]: number;
  } | null;
  /**
   * A fixed set of cost additions for this request
   */
  fixed?: {
    [key: string]: number;
  } | null;
  tips?: WorkflowCostTips;
  /**
   * The total cost of this request, including tips
   */
  total?: number;
};

/**
 * Get the cost of tips
 */
export type WorkflowCostTips = {
  /**
   * The buzz tipped to Civitai
   */
  civitai: number;
  /**
   * The buzz tipped to the Creators who's resources were used
   */
  creators: number;
};

/**
 * Details of a workflow event.
 */
export type WorkflowEvent = {
  /**
   * The ID that represents the corresponding workflow.
   */
  workflowId: string;
  status: WorkflowStatus;
  /**
   * A timestamp for when this event got raised
   */
  timestamp?: string;
  $type?: string;
};

/**
 * Values available to represent workflow status.
 */
export type WorkflowStatus =
  | 'unassigned'
  | 'preparing'
  | 'scheduled'
  | 'processing'
  | 'succeeded'
  | 'failed'
  | 'expired'
  | 'canceled';

/**
 * Values available to represent workflow status.
 */
export const WorkflowStatus = {
  UNASSIGNED: 'unassigned',
  PREPARING: 'preparing',
  SCHEDULED: 'scheduled',
  PROCESSING: 'processing',
  SUCCEEDED: 'succeeded',
  FAILED: 'failed',
  EXPIRED: 'expired',
  CANCELED: 'canceled',
} as const;

/**
 * Details of a workflow step.
 */
export type WorkflowStep = {
  $type: string;
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name: string;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * The jobs generated by this step.
   */
  jobs?: Array<WorkflowStepJob> | null;
  status?: WorkflowStatus;
  /**
   * The date / time the step was started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the step was completed. Null if not yet completed.
   */
  completedAt?: string | null;
  /**
   * A collection of user defined metadata for the workflow step.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Details of a workflow step event.
 */
export type WorkflowStepEvent = {
  /**
   * The workflow ID.
   */
  workflowId: string;
  /**
   * The workflow step's name.
   */
  stepName: string;
  status: WorkflowStatus;
  $type?: string;
};

/**
 * Details of a job produced by a workflow step.
 */
export type WorkflowStepJob = {
  /**
   * The job's ID.
   */
  id: string;
  status?: WorkflowStatus;
  /**
   * The date / time the job started. Null if not yet started.
   */
  startedAt?: string | null;
  /**
   * The date / time the job completed. Null if not yet completed.
   */
  completedAt?: string | null;
  queuePosition?: WorkflowStepJobQueuePosition;
  /**
   * The job's cost.
   */
  cost?: number;
};

/**
 * Details of a workflow step job event.
 */
export type WorkflowStepJobEvent = {
  /**
   * The workflow ID.
   */
  workflowId: string;
  /**
   * The step's name.
   */
  stepName: string;
  /**
   * The job's ID.
   */
  jobId: string;
  status: WorkflowStatus;
  $type?: string;
  progress?: number | null;
  reason?: string | null;
};

/**
 * Details of the workflow step job's queue position.
 */
export type WorkflowStepJobQueuePosition = {
  support: JobSupport;
  /**
   * The number of preceding jobs in the queue.
   */
  precedingJobs?: number | null;
  /**
   * An estimated date / time for when the job will start.
   */
  startAt?: string | null;
  /**
   * An estimated date / time for when the job will complete.
   */
  completeAt?: string | null;
};

/**
 * Details of a workflow step template.
 */
export type WorkflowStepTemplate = {
  $type: string;
  /**
   * The name of the workflow step. Used to allow steps to refer to one another.
   */
  name?: string | null;
  priority?: Priority;
  /**
   * The maximum time to wait for this step to complete.
   */
  timeout?: string | null;
  /**
   * The maximum number of times this step should be retried.
   */
  retries?: number | null;
  /**
   * A collection of user defined metadata for the workflow step.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Details of a requested workflow.
 */
export type WorkflowTemplate = {
  /**
   * A collection of user defined metadata that can be used to store additional information about the workflow.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * A list of tags associated with this workflow.
   * Tags are indexed and can be used to search for workflows.
   * At most 10 tags can be assigned to a workflow. Each tag can be at most 200 characters long.
   */
  tags?: Array<string> | null;
  /**
   * An array of steps that compose this workflow.
   */
  steps: Array<WorkflowStepTemplate>;
  /**
   * An array of callbacks to be triggered during the lifetime of the workflow.
   */
  callbacks?: Array<WorkflowCallback> | null;
  tips?: WorkflowTips;
  /**
   * Get an associated collection of arguments
   */
  arguments?: {
    [key: string]: unknown;
  } | null;
  nsfwLevel?: NSFWLevel;
  /**
   * Get or set whether this workflow is experimental
   */
  experimental?: boolean | null;
};

export type WorkflowTips = {
  /**
   * The rate of tipping that should be allocated to civitai
   */
  civitai: number;
  /**
   * The rate of tipping that should be allocated to creators involved in this workflow
   */
  creators: number;
};

export type PutV2ProvidersBlobsByBlobKeyData = {
  path: {
    blobKey: string;
  };
};

export type PutV2ProvidersBlobsByBlobKeyResponse = unknown;

export type PutV2ProvidersBlobsByBlobKeyError = ProblemDetails;

export type GetBlobData = {
  path: {
    /**
     * The blob ID to retrieve.
     */
    blobId: string;
  };
  query?: {
    /**
     * A maximum nsfw level. If this is specified and the blob does not have a NSFW level specified or the NSFW level exceeds our max then we'll return an error
     */
    nsfwLevel?: NSFWLevel;
  };
};

export type CreateConfigurationData = {
  /**
   * The details of the configuration being created.
   */
  body?: ConfigurationOptions;
};

export type CreateConfigurationResponse = CreateConfigurationResult;

export type CreateConfigurationError = ProblemDetails;

export type QueryConfigurationsResponse = ConfigurationStatus;

export type QueryConfigurationsError = ProblemDetails;

export type GetConfigurationData = {
  path: {
    /**
     * The ID of the configuration whose options are being requested.
     */
    configurationId: string;
  };
};

export type GetConfigurationResponse = ConfigurationOptions;

export type GetConfigurationError = ProblemDetails;

export type DeleteConfigurationData = {
  path: {
    /**
     * The ID of the configuration to delete.
     */
    configurationId: string;
  };
};

export type DeleteConfigurationResponse = unknown;

export type DeleteConfigurationError = ProblemDetails;

export type GetResourceData = {
  path: {
    /**
     * A unique ID for the resource being requested. See https://developer.civitai.com/docs/getting-started/ai-resource-identifier for more info on AIRs.
     */
    air: string;
  };
};

export type GetResourceResponse = ResourceInfo;

export type GetResourceError = ProblemDetails;

export type InvalidateResourceData = {
  path: {
    /**
     * A unique ID for the resource being requested. See https://developer.civitai.com/docs/getting-started/ai-resource-identifier for more info on AIRs.
     */
    air: string;
  };
  query?: {
    /**
     * One or more userIds to invalidate early access for
     */
    userId?: Array<number>;
  };
};

export type InvalidateResourceResponse = void;

export type InvalidateResourceError = ProblemDetails;

export type GetJobsData = {
  path: {
    workerId: string;
  };
  query?: {
    claim?: boolean;
    take?: number;
    wait?: number;
  };
};

export type GetJobsResponse = Array<Job>;

export type GetJobsError = ProblemDetails;

export type DownloadResourceData = {
  path: {
    air: string;
    workerId: string;
  };
};

export type DownloadResourceResponse = ProblemDetails;

export type DownloadResourceError = unknown & ProblemDetails;

export type CreateWorkerData = {
  /**
   * The registration specifying the details of the worker to be created.
   */
  body?: WorkerRegistration;
};

export type CreateWorkerResponse = CreateWorkerResult;

export type CreateWorkerError = ProblemDetails;

export type QueryWorkersResponse = Array<WorkerDetails>;

export type QueryWorkersError = ProblemDetails;

export type GetWorkerData = {
  path: {
    /**
     * The ID for the requested worker.
     */
    workerId: string;
  };
};

export type GetWorkerResponse = WorkerDetails;

export type GetWorkerError = ProblemDetails;

export type DeleteWorkerData = {
  path: {
    /**
     * The ID for the worker to be deleted.
     */
    workerId: string;
  };
};

export type DeleteWorkerResponse = void;

export type DeleteWorkerError = ProblemDetails;

export type GetRegistrationData = {
  path: {
    /**
     * The ID of the worker whose registration is being requested.
     */
    workerId: string;
  };
};

export type GetRegistrationResponse = WorkerRegistration;

export type GetRegistrationError = ProblemDetails;

export type UpdateWorkerRegistrationData = {
  /**
   * The registration details to update on the worker's registration.
   */
  body?: WorkerRegistration;
  path: {
    /**
     * The ID for the worker whose registration is being updated.
     */
    workerId: string;
  };
};

export type UpdateWorkerRegistrationResponse = void;

export type UpdateWorkerRegistrationError = ProblemDetails;

export type PatchWorkerResourcesData = {
  /**
   * A dictionary of resource AIRs and their corresponding status for on that worker.
   */
  body?: {
    [key: string]: WorkerResourceStatus;
  };
  path: {
    /**
     * The ID for the worker whose registration resources are being patched.
     */
    workerId: string;
  };
};

export type PatchWorkerResourcesResponse = void;

export type PatchWorkerResourcesError = ProblemDetails;

export type SubmitWorkflowData = {
  body?: WorkflowTemplate;
  query?: {
    /**
     * Whether to wait for the workflow to complete before returning or to return immediately
     * The request may return a 202 if the clients waits for the workflow to complete and the workflow does not complete within the requested timeout.
     * In which case the client should use the token to query the status of the workflow.
     */
    wait?: number;
    /**
     * Whether to actually submit the workflow or return an estimate on what would happen upon submission
     */
    whatif?: boolean;
  };
};

export type SubmitWorkflowResponse = Workflow;

export type SubmitWorkflowError = ProblemDetails;

export type QueryWorkflowsData = {
  headers?: {
    /**
     * Specify 'application/zip' to get the response as a zip file
     */
    Accept?: string;
  };
  query?: {
    /**
     * An optional cursor to continue querying workflows from a previous query.
     */
    cursor?: string;
    /**
     * An optional list of tags to query by
     */
    tags?: Array<string>;
    /**
     * How many workflows to return
     */
    take?: number;
  };
};

export type QueryWorkflowsResponse = CursedArrayOfTelemetryCursorAndWorkflow;

export type QueryWorkflowsError = ProblemDetails;

export type GetWorkflowData = {
  path: {
    /**
     * The ID of the workflow to get status for
     */
    workflowId: string;
  };
  query?: {
    /**
     * Whether to wait for the workflow to complete before returning or to return immediately
     * The request may return a 202 if the clients waits for the workflow to complete and the workflow does not complete within the requested timeout.
     * In which case the client should use the token to query the status of the workflow.
     */
    wait?: boolean;
  };
};

export type GetWorkflowResponse = Workflow;

export type GetWorkflowError = ProblemDetails;

export type UpdateWorkflowData = {
  /**
   * The details to update on the workflow.
   */
  body?: UpdateWorkflowRequest;
  path: {
    /**
     * The ID of the worfklow to update.
     */
    workflowId: string;
  };
};

export type UpdateWorkflowResponse = void;

export type UpdateWorkflowError = ProblemDetails;

export type PatchWorkflowData = {
  body?: JsonPatchDocument;
  path: {
    workflowId: string;
  };
};

export type PatchWorkflowResponse = void;

export type PatchWorkflowError = ProblemDetails;

export type DeleteWorkflowData = {
  path: {
    /**
     * The ID of the workflow to delete.
     */
    workflowId: string;
  };
};

export type DeleteWorkflowResponse = void;

export type DeleteWorkflowError = ProblemDetails;

export type AddWorkflowTagData = {
  /**
   * The the tag to add to the workflow.
   */
  body?: string;
  path: {
    /**
     * The ID of the worfklow to update.
     */
    workflowId: string;
  };
};

export type AddWorkflowTagResponse = void;

export type AddWorkflowTagError = ValidationProblemDetails & ProblemDetails;

export type RemoveAllWorkflowTagsData = {
  path: {
    /**
     * The ID of the worfklow to update.
     */
    workflowId: string;
  };
};

export type RemoveAllWorkflowTagsResponse = void;

export type RemoveAllWorkflowTagsError = ValidationProblemDetails & ProblemDetails;

export type RemoveWorkflowTagData = {
  path: {
    /**
     * The the tag to remove from the workflow.
     */
    tag: string;
    /**
     * The ID of the worfklow to update.
     */
    workflowId: string;
  };
};

export type RemoveWorkflowTagResponse = void;

export type RemoveWorkflowTagError = ValidationProblemDetails & ProblemDetails;

export type GetWorkflowStepData = {
  path: {
    /**
     * The name of the step within the workflow to get status for
     */
    stepName: string;
    /**
     * The id of the workflow to get status for
     */
    workflowId: string;
  };
};

export type GetWorkflowStepResponse = WorkflowStep;

export type GetWorkflowStepError = ProblemDetails;

export type UpdateWorkflowStepData = {
  /**
   * The details to update on the workflow step.
   */
  body?: UpdateWorkflowStepRequest;
  path: {
    /**
     * The name of the step to update.
     */
    stepName: string;
    /**
     * The id of the workflow to update.
     */
    workflowId: string;
  };
};

export type UpdateWorkflowStepResponse = void;

export type UpdateWorkflowStepError = ProblemDetails;

export type PatchWorkflowStepData = {
  body?: JsonPatchDocument;
  path: {
    stepName: string;
    workflowId: string;
  };
};

export type PatchWorkflowStepResponse = void;

export type PatchWorkflowStepError = ProblemDetails;

export type $OpenApiTs = {
  '/v2/providers/blobs/{blobKey}': {
    put: {
      req: PutV2ProvidersBlobsByBlobKeyData;
      res: {
        /**
         * Accepted
         */
        '202': unknown;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
      };
    };
  };
  '/v2/consumer/blobs/{blobId}': {
    get: {
      req: GetBlobData;
      res: {
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations': {
    post: {
      req: CreateConfigurationData;
      res: {
        /**
         * OK
         */
        '200': CreateConfigurationResult;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
      };
    };
    get: {
      res: {
        /**
         * OK
         */
        '200': ConfigurationStatus;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations/{configurationId}/options': {
    get: {
      req: GetConfigurationData;
      res: {
        /**
         * OK
         */
        '200': ConfigurationOptions;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/providers/configurations/{configurationId}': {
    delete: {
      req: DeleteConfigurationData;
      res: {
        /**
         * OK
         */
        '200': unknown;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/resources/{air}': {
    get: {
      req: GetResourceData;
      res: {
        /**
         * OK
         */
        '200': ResourceInfo;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    delete: {
      req: InvalidateResourceData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/jobs': {
    get: {
      req: GetJobsData;
      res: {
        /**
         * OK
         */
        '200': Array<Job>;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/resources/{air}': {
    get: {
      req: DownloadResourceData;
      res: {
        /**
         * Temporary Redirect
         */
        '307': unknown;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
        /**
         * Error
         */
        default: ProblemDetails;
      };
    };
  };
  '/v2/providers/workers': {
    post: {
      req: CreateWorkerData;
      res: {
        /**
         * Created
         */
        '201': CreateWorkerResult;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
      };
    };
    get: {
      res: {
        /**
         * OK
         */
        '200': Array<WorkerDetails>;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}': {
    get: {
      req: GetWorkerData;
      res: {
        /**
         * OK
         */
        '200': WorkerDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    delete: {
      req: DeleteWorkerData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/registration': {
    get: {
      req: GetRegistrationData;
      res: {
        /**
         * OK
         */
        '200': WorkerRegistration;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    put: {
      req: UpdateWorkerRegistrationData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/providers/workers/{workerId}/registration/resources': {
    patch: {
      req: PatchWorkerResourcesData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Forbidden
         */
        '403': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows': {
    post: {
      req: SubmitWorkflowData;
      res: {
        /**
         * OK
         */
        '200': Workflow;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Too Many Requests
         */
        '429': ProblemDetails;
      };
    };
    get: {
      req: QueryWorkflowsData;
      res: {
        /**
         * OK
         */
        '200': CursedArrayOfTelemetryCursorAndWorkflow;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows/{workflowId}': {
    get: {
      req: GetWorkflowData;
      res: {
        /**
         * OK
         */
        '200': Workflow;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    put: {
      req: UpdateWorkflowData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    patch: {
      req: PatchWorkflowData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    delete: {
      req: DeleteWorkflowData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows/{workflowId}/tags': {
    post: {
      req: AddWorkflowTagData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ValidationProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    delete: {
      req: RemoveAllWorkflowTagsData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ValidationProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows/{workflowId}/tags/{tag}': {
    delete: {
      req: RemoveWorkflowTagData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ValidationProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
  '/v2/consumer/workflows/{workflowId}/steps/{stepName}': {
    get: {
      req: GetWorkflowStepData;
      res: {
        /**
         * OK
         */
        '200': WorkflowStep;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    put: {
      req: UpdateWorkflowStepData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Bad Request
         */
        '400': ProblemDetails;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
    patch: {
      req: PatchWorkflowStepData;
      res: {
        /**
         * No Content
         */
        '204': void;
        /**
         * Unauthorized
         */
        '401': ProblemDetails;
        /**
         * Not Found
         */
        '404': ProblemDetails;
      };
    };
  };
};
